This file is concerned with the various instruction formats
______________________________________________________________________________________________________________________________________________________________________

legend {

    OPCODE -> operation code
    MOD -> mode
    RD -> register destination
    RSn -> register source n
    IMn -> immediate value n
    MSK -> mask register
    'x' -> don't care
}

MSK(02) indicates the execution mask for both scalar & vector instructions. FabRISC provides 3 masks that can be selected:

    00 -> always true
    01 -> mask 0
    10 -> mask 1
    11 -> mask 2

masks can be set conditionally with dedicated instructions.
______________________________________________________________________________________________________________________________________________________________________

TODO: normalize the bits (permute bits to make it easier to decode)

[A] |OPCODE(12)|MOD(05)|RA(05)|RB(05)|RC(05)| { OK

    - length: 4B

    MOD(05):

        x mstt

    ('tt' is data type length: 8, 16, 32, 64)
    ('s' is sign: 0 signed, 1 unsigned)
    ('m' is maks: 0 unmasked, 1 masked)
    NOTE: computational r,r,r

    MOD(05):

        m00tt -> unfenced
        m01tt -> acquire
        m10tt -> release
        m11tt -> acquire & release

    ('tt' is data type length: 8, 16, 32, 64)
    ('m' is mask: 0 unmasked, 1 masked)
    NOTE: atomic memory
}
______________________________________________________________________________________________________________________________________________________________________

[B] |OPCODE(09)|MOD(05)|RA(05)|RB(05)|IMM(08/24)| { OK

    - lengths: 4B, 6B

    MOD(05):

        mlstt

    ('tt' is data type length: 8, 16, 32, 64)
    ('s' is sign: 0 signed, 1 unsigned)
    ('l' is immediate length: 08, 24)
    ('m' is mask: 0 unmasked, 1 masked)
    NOTE: computational r,r,i
}
______________________________________________________________________________________________________________________________________________________________________

[C] |OPCODE(16)|MOD(06)|RA(05)|RB(05)| { OK

    - length: 4B

    MOD(06):

        xx mstt

    ('tt' is data type length: 8, 16, 32, 64)
    ('s' is sign: 0 signed, 1 unsigned)
    ('m' is maks: 0 unmasked, 1 masked)
    NOTE: computational r,r

    MOD(06):

        x m00tt -> file_0 - file_2
        x m01tt -> file_2 - file_0
        x m1000 -> VFLG - file_0
        x m1001 -> file_0 - VFLG
        x m1010 -> VFLG - file_1
        x m1011 -> file_1 - VFLG

    ('tt' is data type length: 8, 16, 32, 64)
    ('m' is maks: 0 unmasked, 1 masked)
    NOTE: special moves

    MOD(06):

        ms0000 -> 8-16
        ms0001 -> 8-32
        ms0010 -> 8-64
        ms0011 -> 16-8
        ms0100 -> 16-32
        ms0101 -> 16-64
        ms0110 -> 32-8
        ms0111 -> 32-16
        ms1000 -> 32-64
        ms1001 -> 64-8
        ms1010 -> 64-16
        ms1011 -> 64-32

    ('s' is sign: 0 signed, 1 unsigned)
    ('m' is maks: 0 unmasked, 1 masked)
    NOTE: casts

    MOD(06):

        00mstt -> EQ
        01mstt -> NE
        10mstt -> LT
        11mstt -> LE

    ('tt' is data type length: 8, 16, 32, 64)
    ('s' is sign: 0 signed, 1 unsigned)
    ('m' is maks: 0 unmasked, 1 masked)
    NOTE: conditional compare mask setting
}
______________________________________________________________________________________________________________________________________________________________________

[D] |OPCODE(06)|MOD(04)|RA(05)|RB(05)|IMM(12/28)| { OK

    - lengths: 4B, 6B

    MOD(04):

        mltt

    ('tt' is data type length: 8, 16, 32, 64)
    ('l' is immediate length: 12, 28)
    ('m' is mask: 0 unmasked, 1 masked)
    NOTE: scalar memory transfers. address = (RB + IMM)

    MOD(04):

        x aml

    ('l' is immediate length: 12, 28)
    ('m' is mask: 0 unmasked, 1 masked)
    ('a' is addressing mode: standard, striding)
    NOTE: vector memory transfers:

        - standard -> address = (RB + IMM)
        - striding -> IMM is used to indicate the stride
}
______________________________________________________________________________________________________________________________________________________________________

[E] |OPCODE(06)|MOD(03)|RA(05)|RB(05)|RC(05)|IMM(08/16)| { OK

    - lengths: 4B, 6B

    MOD(03):

        ltt

    ('tt' is data type length: 8, 16, 32, 64)
    ('l' is immediate length: 08, 16)
    NOTE: scalar memory transfers. address = (RB + (RC * IMM))

    MOD(03):

        aml

    ('l' is immediate length: 08, 16)
    ('m' is mask: 0 unmasked, 1 masked)
    ('a' is addressing mode: standard, striding)
    NOTE: vector memory transfers:

        - standard -> address = (RB + (RC * IMM))
        - striding -> address = (RB + RC), IMM is used to indicate the stride
}
______________________________________________________________________________________________________________________________________________________________________

[F] |OPCODE(09)|MOD(03)|RA(05)|RB(05)|RC(05)|RD(05)| { OK

    - length: 4B

    MOD(03):

        mtt

    ('tt' is data type length: 8, 16, 32, 64)
    ('m' is mask: 0 unmasked, 1 masked)
    NOTE: scalar memory transfers. address = (RB + (RC * RD))

    MOD(03):

        x am

    ('m' is mask: 0 unmasked, 1 masked)
    ('a' is addressing mode: standard, striding)
    NOTE: vector memory transfers:

        - standard -> address = (RB + (RC * RD))
        - striding -> address = (RB + RC), RD is used to indicate the stride
}
______________________________________________________________________________________________________________________________________________________________________

[G] |OPCODE(07)|MOD(04)|RA(05)|IMM(16/32)| { OK

    - lengths: 4B, 6B

    MOD(04):

        0000 -> file_0 lower l16
        0001 -> file_0 upper l16
        0010 -> file_0 l32

        0011 -> file_1 lower l16
        0100 -> file_1 upper l16
        0101 -> file_1 l32

        0110 -> file_2 lower l16
        0111 -> file_2 upper l16
        1000 -> file_2 l32

    NOTE: block memory

    MOD(04):

        lfff -> flag branch

    ('fff' is the flag specifier)
    ('l' is immediate length: 16, 32)
    NOTE: flag branches
}
______________________________________________________________________________________________________________________________________________________________________

[H] |OPCODE(07)|MOD(03)|RA(05)|RB(05)|IMM(12/28)| { OK

    - lengths: 4B, 6B

    MOD(03):

        ltt

    ('tt' is data type length: 8, 16, 32, 64)
    ('l' is immediate length: 12, 28)
    NOTE: register compare branches
}
______________________________________________________________________________________________________________________________________________________________________

[I] |OPCODE(07)|MOD(05)|RA(05)|IMM(15/31)| { OK

    - lengths: 4B, 6B

    MOD(05):

        l00tt -> EQZ
        l01tt -> NEZ
        l10tt -> LTZ
        l11tt -> LEZ

    ('tt' is data type length: 8, 16, 32, 64)
    ('l' is immediate length: 12, 28)
    NOTE: compare with zero branches
}
______________________________________________________________________________________________________________________________________________________________________

[J] |OPCODE(07)|MOD(01)|RA(05)|IMM(19/35)| { OK

    - lengths: 4B, 6B

    MOD(01):

        l

    ('l' is immediate length: 19, 35)
    NOTE: immediate function calls (RAS hint: push)
}
______________________________________________________________________________________________________________________________________________________________________

[K] |OPCODE(07)|MOD(01)|RA(05)|RB(05)|IMM(14/30)| { OK

    - lengths: 4B, 6B

    MOD(01):

        l

    ('l' is immediate length: 14, 30)
    NOTE: register function calls (RAS hint: push)
}
______________________________________________________________________________________________________________________________________________________________________

[M] |OPCODE(07)|MOD(03)|RD/RS1(03)|RS2(03)| {

    - length: 2B

    MOD(03):

        stt

    ('tt' is data type length: 8, 16, 32, 64)
    ('s' is sign: 0 signed, 1 unsigned)
    NOTE: compressed computational r-r
}
______________________________________________________________________________________________________________________________________________________________________

[N] |OPCODE(06)|RA(03)|IMM(07)| {

    - length: 2B
    NOTE: compressed computational r-i & test branches
}
______________________________________________________________________________________________________________________________________________________________________

[O] |OPCODE(07)|IMM(09)| {

    - length: 2B

    ...
}
______________________________________________________________________________________________________________________________________________________________________

[P] |OPCODE(07)|MOD(04)|RA(05)| {

    - length: 2B

    ...
}
______________________________________________________________________________________________________________________________________________________________________

0000xxxxxxxxxxxx ... 0011xxxxxxxxxxxx  max:  4; current:  4; free:  0; cost_per_unit: 4096;
010000xxxxxxxxxx ... 011011xxxxxxxxxx  max: 12; current:  8; free:  4; cost_per_unit: 1024;
0111000xxxxxxxxx ... 1100111xxxxxxxxx  max: 48; current: 31; free: 17; cost_per_unit:  512;
110100000xxxxxxx ... 111110011xxxxxxx  max: 84; current: 76; free:  8; cost_per_unit:  128;
111110100000xxxx ... 111111110111xxxx  max: 88; current: 72; free: 16; cost_per_unit:   16;
1111111110000000 ... 1111111110111111  max: 64; current: 50; free: 14; cost_per_unit:    1;

max opcode pool: 300
currently used: 241
______________________________________________________________________________________________________________________________________________________________________

000000xxxxxxxxxx ... 011111xxxxxxxxxx   32
1000000xxxxxxxxx ... 1100111xxxxxxxxx   40
110100000xxxxxxx ... 111110011xxxxxxx   84
111110100000xxxx ... 111111110111xxxx   88
1111111110000000 ... 1111111110111111   64
