This file is concerned with the various instruction formats
______________________________________________________________________________________________________________________________________________________________________

legend {

    OPCODE -> operation code
    MOD    -> mode
    Rn     -> register n
    IMM    -> immediate value
    'x'    -> don't care
}
______________________________________________________________________________________________________________________________________________________________________

[A] |OPCODE(12)|MOD(05)|RA(05)|RB(05)|RC(05)| { OK

    - length: 4B

    computational r,r,r:

        MOD(05):

            x mstt

        ('tt' is data type length: 8, 16, 32, 64)
        ('s' is sign: 0 signed, 1 unsigned)
        ('m' is maks: 0 unmasked, 1 masked)

    atomic memory:

        MOD(05):

            m00tt -> unfenced
            m01tt -> acquire
            m10tt -> release
            m11tt -> acquire & release

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is mask: 0 unmasked, 1 masked)
}
______________________________________________________________________________________________________________________________________________________________________

[B] |OPCODE(09)|MOD(05)|RA(05)|RB(05)|IMM(08/24)| { OK

    - lengths: 4B, 6B

    computational r,r,i:

        MOD(05):

            mlstt

        ('tt' is data type length: 8, 16, 32, 64)
        ('s' is sign: 0 signed, 1 unsigned)
        ('l' is immediate length: 08, 24)
        ('m' is mask: 0 unmasked, 1 masked)
}
______________________________________________________________________________________________________________________________________________________________________

[C] |OPCODE(16)|MOD(06)|RA(05)|RB(05)| { OK

    - length: 4B

    computational r,r:
    
        MOD(06):

            xx mstt

        ('tt' is data type length: 8, 16, 32, 64)
        ('s' is sign: 0 signed, 1 unsigned)
        ('m' is maks: 0 unmasked, 1 masked)

    special moves:
    
        MOD(06):

            x m00tt -> file_0 - file_2
            x m01tt -> file_2 - file_0
            x m1000 -> VFLG - file_0
            x m1001 -> file_0 - VFLG
            x m1010 -> VFLG - file_1
            x m1011 -> file_1 - VFLG

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)

        WARNING: fencing here is not needed anymore since there are dedicated ones

    casts & conversions:
    
        MOD(06):

            ms0000 -> 8-16
            ms0001 -> 8-32
            ms0010 -> 8-64
            ms0011 -> 16-8
            ms0100 -> 16-32
            ms0101 -> 16-64
            ms0110 -> 32-8
            ms0111 -> 32-16
            ms1000 -> 32-64
            ms1001 -> 64-8
            ms1010 -> 64-16
            ms1011 -> 64-32

        ('s' is sign: 0 signed, 1 unsigned)
        ('m' is maks: 0 unmasked, 1 masked)

    conditional compare mask setting:
    
        MOD(06):

            00mstt -> EQ
            01mstt -> NE
            10mstt -> LT
            11mstt -> LE

        ('tt' is data type length: 8, 16, 32, 64)
        ('s' is sign: 0 signed, 1 unsigned)
        ('m' is maks: 0 unmasked, 1 masked)
}
______________________________________________________________________________________________________________________________________________________________________

[D] |OPCODE(06)|MOD(04)|RA(05)|RB(05)|IMM(12/28)| { OK

    - lengths: 4B, 6B

    scalar memory transfers:
    
        MOD(04):

            mltt

        ('tt' is data type length: 8, 16, 32, 64)
        ('l' is immediate length: 12, 28)
        ('m' is mask: 0 unmasked, 1 masked)
        address = (RB + IMM)

    vector memory transfers:
    
        MOD(04):

            x aml

        ('l' is immediate length: 12, 28)
        ('m' is mask: 0 unmasked, 1 masked)
        ('a' is addressing mode: standard, striding)
        - standard -> address = (RB + IMM)
        - striding -> IMM is used to indicate the stride
}
______________________________________________________________________________________________________________________________________________________________________

[E] |OPCODE(06)|MOD(03)|RA(05)|RB(05)|RC(05)|IMM(08/16)| { OK

    - lengths: 4B, 6B

    scalar memory transfers:
    
        MOD(03):

            ltt

        ('tt' is data type length: 8, 16, 32, 64)
        ('l' is immediate length: 08, 16)
        address = (RB + (RC * IMM))

    vector memory transfers:
    
        MOD(03):

            aml

        ('l' is immediate length: 08, 16)
        ('m' is mask: 0 unmasked, 1 masked)
        ('a' is addressing mode: standard, striding)
        - standard -> address = (RB + (RC * IMM))
        - striding -> address = (RB + RC), IMM is used to indicate the stride
}
______________________________________________________________________________________________________________________________________________________________________

[F] |OPCODE(09)|MOD(03)|RA(05)|RB(05)|RC(05)|RD(05)| { OK

    - length: 4B

    scalar memory transfers:
    
        MOD(03):

            mtt

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is mask: 0 unmasked, 1 masked)
        address = (RB + (RC * RD))

    vector memory transfers:
    
        MOD(03):

            x am

        ('m' is mask: 0 unmasked, 1 masked)
        ('a' is addressing mode: standard, striding)
        - standard -> address = (RB + (RC * RD))
        - striding -> address = (RB + RC), RD is used to indicate the stride
}
______________________________________________________________________________________________________________________________________________________________________

[G] |OPCODE(07)|MOD(04)|RA(05)|IMM(16/32)| { OK

    - lengths: 4B, 6B

    block memory:
    
        MOD(04):

            0000 -> file_0 lower l16
            0001 -> file_0 upper l16
            0010 -> file_0 l32

            0011 -> file_1 lower l16
            0100 -> file_1 upper l16
            0101 -> file_1 l32

            0110 -> file_2 lower l16
            0111 -> file_2 upper l16
            1000 -> file_2 l32

    flag branches:
    
        MOD(04):

            lfff -> flag branch

        ('fff' is the flag specifier)
        ('l' is immediate length: 16, 32)
}
______________________________________________________________________________________________________________________________________________________________________

[H] |OPCODE(07)|MOD(03)|RA(05)|RB(05)|IMM(12/28)| { OK

    - lengths: 4B, 6B

    register compare branches:
    
        MOD(03):

            ltt

        ('tt' is data type length: 8, 16, 32, 64)
        ('l' is immediate length: 12, 28)
}
______________________________________________________________________________________________________________________________________________________________________

[I] |OPCODE(07)|MOD(05)|RA(05)|IMM(15/31)| { OK

    - lengths: 4B, 6B

    compare with zero branches:
    
        MOD(05):

            l00tt -> EQZ
            l01tt -> NEZ
            l10tt -> LTZ
            l11tt -> LEZ

        ('tt' is data type length: 8, 16, 32, 64)
        ('l' is immediate length: 12, 28)
}
______________________________________________________________________________________________________________________________________________________________________

[J] |OPCODE(06)|MOD(01)|RA(05)|IMM(20/36)| { OK

    - lengths: 4B, 6B

    immediate function calls:
    
        MOD(01):

            l

        ('l' is immediate length: 20, 36)
        (RAS hint: push)
}
______________________________________________________________________________________________________________________________________________________________________

[K] |OPCODE(06)|MOD(01)|RA(05)|RB(05)|IMM(15/31)| { OK

    - lengths: 4B, 6B

    register function calls:
    
        MOD(01):

            l

        ('l' is immediate length: 20, 36)
        (RAS hint: push)
}
______________________________________________________________________________________________________________________________________________________________________

[M] |OPCODE(07)|MOD(03)|RD/RS1(03)|RS2(03)| { OK

    - length: 2B

    compressed computational r-r:
    
        MOD(03):

            stt

        ('tt' is data type length: 8, 16, 32, 64)
        ('s' is sign: 0 signed, 1 unsigned)
}
______________________________________________________________________________________________________________________________________________________________________

[N] |OPCODE(06)|RA(03)|IMM(07)| { OK

    - length: 2B

    compressed computational r-i
    compressed test branches
}
______________________________________________________________________________________________________________________________________________________________________

[O] |OPCODE(07)|IMM(09)| {

    - length: 2B

    ...
}
______________________________________________________________________________________________________________________________________________________________________

[P] |OPCODE(07)|MOD(04)|RA(05)| { OK

    - length: 2B

    miscellaneous instructions:

        MOD(04):

            - MOD(04) is treated as a nested opcode
            - see instruction list
}
______________________________________________________________________________________________________________________________________________________________________

0000xxxxxxxxxxxx ... 0011xxxxxxxxxxxx  max:  4; current:  4; free:  0; cost_per_unit: 4096;
010000xxxxxxxxxx ... 011011xxxxxxxxxx  max: 12; current:  8; free:  4; cost_per_unit: 1024;
0111000xxxxxxxxx ... 1100111xxxxxxxxx  max: 48; current: 31; free: 17; cost_per_unit:  512;
110100000xxxxxxx ... 111110011xxxxxxx  max: 84; current: 76; free:  8; cost_per_unit:  128;
111110100000xxxx ... 111111110111xxxx  max: 88; current: 72; free: 16; cost_per_unit:   16;
1111111110000000 ... 1111111110111111  max: 64; current: 50; free: 14; cost_per_unit:    1;

max opcode pool: 300
currently used: 241
______________________________________________________________________________________________________________________________________________________________________

000000xxx xxxxxxx ... 011111xxx xxxxxxx   32
1000000xx xxxxxxx ... 1100111xx xxxxxxx   40
110100000 xxxxxxx ... 111110011 xxxxxxx   84
111110100 000xxxx ... 111111110 111xxxx   88
111111111 0000000 ... 111111111 0111111   64

[A]: 72
[B]: 72
[C]: 50
[D]:  4
[E]:  4
[F]:  4
[G]:  2
[H]: 12
[I]:  4
[J]:  1
[K]:  1
[M]: 10
[N]: ??
[O]: ??
[P]:  1
