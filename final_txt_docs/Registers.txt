This file is concerned with the register ABI specification

FabRISC has 3 register files: 2 general purpose and 1 special purpose
______________________________________________________________________________________________________________________________________________________________________

FILE 0 {

    - 32 scalar general purpose registers
    - integer & floating point are shared

    $00--------(P0 "function parameter 00")
    $01--------(P1 "function parameter 01")
    $02--------(P2 "function parameter 02")
    $03--------(P3 "function parameter 03")

    $04--------(R0 "function return value 00")
    $05--------(R1 "function return value 01")

    $06--------(S0 "persistent register 00")
    $07--------(S1 "persistent register 01")
    $08--------(S2 "persistent register 02")
    $09--------(S3 "persistent register 03")
    $10--------(S4 "persistent register 04")
    $11--------(S5 "persistent register 05")
    $12--------(S6 "persistent register 06")
    $13--------(S7 "persistent register 07")
    $14--------(S8 "persistent register 08")
    $15--------(S9 "persistent register 09")
    $16--------(S10 "persistent register 10")
    $17--------(S11 "persistent register 11")
    $18--------(S12 "persistent register 12")
    $19--------(S13 "persistent register 13")
    $20--------(S14 "persistent register 14")
    $21--------(S15 "persistent register 15")
    $22--------(S16 "persistent register 16")
    $23--------(S17 "persistent register 17")

    $24--------(N0 "volatile register 00")
    $25--------(N1 "volatile register 01")
    $26--------(N2 "volatile register 02")
    $27--------(N3 "volatile register 03")

    $28--------(GP "global pointer")
    $29--------(SP "stack pointer")
    $30--------(FP "frame pointer")
    $31--------(RA "return address")



    the processor doesn't actually care how registers are used. All instructions, except compressed, can address any register at any time.
    this ABI is just a convention to make code more coherent and reliable:

        GP -> points to the global / static variable space
        SP -> points to the base of the stack
        FP -> points to the base of the current stack frame
        RA -> holds the function return address

    all registers are word bits wide (either 32 or 64 bits).

    NOTE: the callee must save any "persistent register" that he intends to utilize. This is because the caller expects those registers to retain
    their value across calls. (callee saved)

    NOTE: the caller must save any "volatile register" before a call if they hold important values. This is because those registers are not
    expected to retain their value across calls. (caller saved)

    TODO: reorder the regs ABI to improve the power of compressed instructions
}

FILE 1 {

    - 32 vector general purpose registers
    - integer & floating point are shared

    &00--------(V0 "vector general purpose register 00")
    &01--------(V1 "vector general purpose register 01")
    &02--------(V2 "vector general purpose register 02")
    &03--------(V3 "vector general purpose register 03")
    &04--------(V4 "vector general purpose register 04")
    &05--------(V5 "vector general purpose register 05")
    &06--------(V6 "vector general purpose register 06")
    &07--------(V7 "vector general purpose register 07")
    &08--------(V8 "vector general purpose register 08")
    &09--------(V9 "vector general purpose register 09")
    &10--------(V10 "vector general purpose register 10")
    &11--------(V11 "vector general purpose register 11")
    &12--------(V12 "vector general purpose register 12")
    &13--------(V13 "vector general purpose register 13")
    &14--------(V14 "vector general purpose register 14")
    &15--------(V15 "vector general purpose register 15")
    &16--------(V16 "vector general purpose register 16")
    &17--------(V17 "vector general purpose register 17")
    &18--------(V18 "vector general purpose register 18")
    &19--------(V19 "vector general purpose register 19")
    &20--------(V20 "vector general purpose register 20")
    &21--------(V21 "vector general purpose register 21")
    &22--------(V22 "vector general purpose register 22")
    &23--------(V23 "vector general purpose register 23")
    &24--------(V24 "vector general purpose register 24")
    &25--------(V25 "vector general purpose register 25")
    &26--------(V26 "vector general purpose register 26")
    &27--------(V27 "vector general purpose register 27")
    &28--------(V28 "vector general purpose register 28")
    &29--------(V29 "vector general purpose register 29")
    &30--------(V30 "vector general purpose register 30")
    &31--------(V31 "vector general purpose register 31")



    all registers have the same length. Possible lengths can be:

        -  64 bits (for 32 bit machines)
        - 128 bits (for 32 & 64 bit machines)
        - 256 bits (for 32 & 64 bit machines)
        - 512 bits (for 32 & 64 bit machines)
}

FILE 2 {

    - 32 special purpose registers of different possible lengths
    - * are privileged resources

    %00--------(VR_04 "volatile register 04")-------------[width: word]     <<<<
    %01--------(VR_05 "volatile register 05")-------------[width: word]     <<<<
    %02--------(VR_06 "volatile register 06")-------------[width: word]     <<<<
    %03--------(VR_07 "volatile register 07")-------------[width: word]     <<<<

    %04--------(BR_00 "breakpoint register 00")-----------[width: word]
    %05--------(BR_01 "breakpoint register 01")-----------[width: word]
    %06--------(BR_02 "breakpoint register 02")-----------[width: word]
    %07--------(BR_03 "breakpoint register 03")-----------[width: word]
    %08--------(BR_04 "breakpoint register 04")-----------[width: word]
    %09--------(BR_05 "breakpoint register 05")-----------[width: word]
    %10--------(BR_06 "breakpoint register 06")-----------[width: word]
    %11--------(BR_07 "breakpoint register 07")-----------[width: word]

    %12--------(BM "breakpoint modes")--------------------[width: 32 bits]
    %13--------(PC "program counter")---------------------[width: word]
    %14--------(UEB_0 "user event buffer 0")--------------[width: word]
    %15--------(UEB_1 "user event buffer 1")--------------[width: word]

    %16--------(VFLG "vector flags")----------------------[width: vector length]
    %17--------(VMSK "vector mask")-----------------------[width: word]

    %18--------(UETP "user event table pointer")----------[width: word]     <<<<

  * %19--------(FU0 "file usage 0")-----------------------[width: 32 bits]
  * %20--------(FU1 "file usage 1")-----------------------[width: 32 bits]
  * %21--------(FU2 "file usage 2")-----------------------[width: 32 bits]

  * %22--------(PID "process identifier")-----------------[width: 32 bits]
  * %23--------(CSR "control & status register")----------[width: 32 bits]
  * %24--------(SEB_0 "supervisor event buffer 0")--------[width: word]
  * %25--------(SEB_1 "supervisor event buffer 1")--------[width: word]
  * %26--------(SETP "supervisor event table pointer")----[width: word]
  * %27--------(PTP "page table pointer")-----------------[width: word]

  * %28--------(KR_0 "kernel reserved 0")-----------------[width: word]     <<<<
  * %29--------(KR_1 "kernel reserved 1")-----------------[width: word]     <<<<
  * %30--------(KR_2 "kernel reserved 2")-----------------[width: word]
  * %31--------(KR_3 "kernel reserved 3")-----------------[width: word]
}
______________________________________________________________________________________________________________________________________________________________________

breakpoint registers {

    breakpoint registers are special registers that can be used for:

        - debugging
        - specific exception generation
        - bound checking
        - and more...

    for each breakpoint register, there is a 4 bit code in the BM register. Depending on the mode and the value of a particular
    breakpoint register, an event can be triggered.

    modes:

        0000 -> disabled
        0001 -> break on instruction address EQ
        0010 -> break on instruction address LE
        0011 -> break on instruction address GE
        0100 -> break on data read address EQ
        0101 -> break on data read address LE
        0110 -> break on data read address GE
        0111 -> break on data write address EQ
        1000 -> break on data write address LE
        1001 -> break on data write address GE
        1010 -> break on instruction
        1011 -> break on COVR flag
        1100 -> break on CUND flag
        1101 -> break on OVFL flag
        1110 -> break on UNFL flag
        1111 -> break on DIV0 flag


        0000 -> clk counter
        0001 -> 
        0010 -> 
        0011 -> 
        0100 -> 
        0101 -> 
        0110 -> 
        0111 -> 
        1000 -> 
        1001 -> 
        1010 -> 
        1011 -> 
        1100 -> 
        1101 -> 
        1110 -> 
        1111 -> 


    for example (assuming 64 bit architecture), setting a value of 0x0000000012345678 in the register BP_0 and a value of 0x0000000000000001 in the BM register will only
    enable BP_0 with "break on instruction address" mode. This mode will trigger a breakpoint exception if the PC ever reaches a value of
    0x0000000012345678.

    NOTE: inactive breakpoint registers can still be used as temporary buffers for any purpose, however, this ABI doesn't specify what to do in that case
    meaning that it's up to the programmers to agree.
}
______________________________________________________________________________________________________________________________________________________________________

vector flags {

    the VFLG register holds the flags generated by vector instructions. The flags are exactly the same as the scalar flags and each lane has it's own
    independent set of flags, which means that this register has the same length as any other vector register. In total each flag will be replicated as many
    times as the number of smallest lane (8 bit lane). For example, if the vector registers are 512 bits long, each flag will be replicated 64 times (512 / 8).
    This way it becomes possible to check individual flags for each specific lane.

    NOTE: vector flags can trap, however, only 1 trap can be generated per instruction. For example, if a vector-vector division by zero generates 6 DIV0
    flags, there will be only 1 DIV0 exception and the appropriate DIV0 flags will still be set normally.
}
______________________________________________________________________________________________________________________________________________________________________

vector mask {

    the VMSK register holds the mask bits for conditional vector execution. Each lane will be masked by a single bit that "allows" the particular lane to write
    the result. For convention a 0 will not mask (allow) and a 1 will mask (not allow). A value of all 0s in VMSK simply results in unconditional vector
    execution. VMSK can be set to the desired value with dedicated instructions. VMSK dedicates 1 bit for each possible smallest lane (8 bit lane). For example,
    if the vector registers are 512 bits long, VMSK will be 64 bits long.
}
______________________________________________________________________________________________________________________________________________________________________

event buffers {

    there are 4 event buffer registers: 2 for the user and 2 for the supervisor. These registers are used to save the PC and the CSR registers in case of an
    event. Depending on the privilege of the event, PC and CSR will be saved in different event buffer registers.

    any user event:

        PC  -> UEB_0
        CSR -> UEB_1

    any supervisor event:

        PC  -> SEB_0
        CSR -> SEB_1

    returning from an event causes the movement of the appropriate event buffers back into PC and CSR.

    NOTE: the processor must move PC and CSR to and from the appropriate event buffer automatically as soon as an event is triggered or returned.
}
______________________________________________________________________________________________________________________________________________________________________

event table pointers {

    these registers are "set and forget" registers whose purpose is to point to the event handling tables. UETP points to the event table dedicated for the user,
    while SETP points to the event table dedicated for the supervisor.
}
______________________________________________________________________________________________________________________________________________________________________

page table pointer {

    this register is a dedicated register used by the MMU to perform the page table walk. on a TLB miss, the processor will fetch the appropriate page table
    entry from the page table pointed by PTP. Since page table addresses are unique for every process, this register must be set to the proper address by the
    kernel during process scheduling.
}
______________________________________________________________________________________________________________________________________________________________________

control & status register {

    the CSR register hold a series of bits and flags that affects how the processor operates.

        flags section {

            - COVR (1) (carry over flag)
            - CUND (1) (carry under flag)
            - OVFL (1) (overflow flag)
            - UNFL (1) (underflow flag)
            - DIV0 (1) (division by 0 flag)
            - ZERO (1) (zero flag)
            - SIGN (1) (sign flag)
            - //   (1)
        }

        instruction behavior {

            - LEN  (2) (data type length)
            - VLEN (6) (vector length)
            - IMOD (3) (instruction mode)
            - RMD  (2) (floating point rounding modes)
            - SMSK (1) (scalar mask)
        }

        transactional memory {

            - TRD  (8) (transaction nesting depth counter)
        }

        system {

          * - SUP  (1) (supervisor mode)
          * - BOOT (1) (boot mode)
          * - CON  (1) (consistency mode)
          * - PAG  (1) (enable paging)
            - EXC  (1) (enable auto exceptions)
          * - UINT (1) (enable user interrupts)
            - SINT (1) (enable supervisor interrupts)
          * - EVT  (1) (event triggered)
          * - HLT  (1) (halt execution)
        }

        - //

    NOTE: in case of multi-core systems, BOOT should only concern the bootstrapping core, for example core 0. All the other cores
    must start in a halted state. Unlocking cores can be done with special waking interrupts.
}
______________________________________________________________________________________________________________________________________________________________________

process id register {

    the PID register holds the current executing process ID. In case of a promoting event, the processor should automatically change
    the value of this register to the ID of the kernel, for example all 0s. The MMU can to avoid flushing the TLB during context
    switches with the help of the PID register to filter accesses to similar logical addresses potentially reducing page misses.
}
______________________________________________________________________________________________________________________________________________________________________

file usage registers {

    FU0, FU1, FU2 are three special transparent registers used by the processor to indicate which register in which file was modified since the scheduling
    of the current process. Each bit represents a single register in the appropriate file and values are automatically set. The supervisor can use this
    information along with "State Dump" and "State Restore" instructions to easily and quickly save or restore the state of the processor to and from memory.
}
______________________________________________________________________________________________________________________________________________________________________


new special reg file test:

  * %19--------(FU0 "file usage 0")-----------------------[width: 32 bits]
  * %20--------(FU1 "file usage 1")-----------------------[width: 32 bits]
  * %21--------(FU2 "file usage 2")-----------------------[width: 32 bits]

  * %22--------(PID "process identifier")-----------------[width: 32 bits]
  * %23--------(CSR "control & status register")----------[width: 32 bits]
  * %24--------(SEB_0 "supervisor event buffer 0")--------[width: word]
  * %25--------(SEB_1 "supervisor event buffer 1")--------[width: word]
  * %26--------(SETP "supervisor event table pointer")----[width: word]
  * %27--------(PTP "page table pointer")-----------------[width: word]

  * %28--------(KR_0 "kernel reserved 0")-----------------[width: word]
  * %29--------(KR_1 "kernel reserved 1")-----------------[width: word]
  * %30--------(KR_2 "kernel reserved 2")-----------------[width: word]
  * %31--------(KR_3 "kernel reserved 3")-----------------[width: word]



    %00--------(BR_00 "breakpoint register 00")-----------[width: word]
    %01--------(BR_01 "breakpoint register 01")-----------[width: word]
    %02--------(BR_02 "breakpoint register 02")-----------[width: word]
    %03--------(BR_03 "breakpoint register 03")-----------[width: word]
    %04--------(BR_04 "breakpoint register 04")-----------[width: word]
    %05--------(BR_05 "breakpoint register 05")-----------[width: word]
    %06--------(BR_06 "breakpoint register 06")-----------[width: word]
    %07--------(BR_07 "breakpoint register 07")-----------[width: word]
    %08--------(BR_08 "breakpoint register 08")-----------[width: word]
    %09--------(BR_09 "breakpoint register 09")-----------[width: word]
    %10--------(BR_10 "breakpoint register 10")-----------[width: word]

    %11--------(BM_0 "breakpoint modes 0")----------------[width: 32 bits]
    %12--------(BM_1 "breakpoint modes 1")----------------[width: 32 bits]
    %13--------(PC "program counter")---------------------[width: word]
    %14--------(UEB_0 "user event buffer 0")--------------[width: word]
    %15--------(UEB_1 "user event buffer 1")--------------[width: word]
    %16--------(UETP "user event table pointer")----------[width: word]

    %17--------(VMSK "vector mask")-----------------------[width: word]
    %18--------(VFLG "vector flags")----------------------[width: vector length]
    ...