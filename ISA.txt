final ISA version (i hope...)
this is just a quick text file, the fancy PDF is on the way...
______________________________________________________________________________________________________________________________________________________________________

INSTRUCTION FORMATS {

    NOTE: these formats are not normalized, the bits are not in their optimal position
    NOTE: the instructions are listed with: [format] + (mnemonic) + "name" + (altered flags) + {opcode combination}
    NOTE: // means unused
    NOTE: * indicates a privileged resource

    quick acronym legend:

        - MOD -> "mode"
        - RD -> "register destination"
        - RSn -> "register source n"
        - OPCODE -> "operation code"
        - IMn -> "immediate n"
        - LEN -> length specifier (see CSR bit layout in the REGISTERS section)
        - IMOD -> instruction mode specifier (see CSR bit layout in the REGISTERS section)

    NOTE: numbers in parentheses specifies the length of the particular field (in bits)

    Computational {

        [A] |OPCODE(13)|MOD(04)|RD(05)|RS1(05)|RS2(05)| { ok

            - length: 4 bytes always

            MOD(04):

                00mm -> scalar
                01mm -> vector-vector
                10mm -> vector-scalar
                1100 -> scalar LEN
                1101 -> vector-vector LEN
                1110 -> vector-scalar LEN
                1111 -> IMOD LEN

                (mm is length: 8, 16, 32, 64)
        }

        [B] |OPCODE(09)|MOD(05)|RD(05)|RS1(05)|IM1(08/24/40)| { ok

            - lengths: 4, 6, 8 bytes

            MOD(05):

                000mm -> scalar l08
                001mm -> scalar l24
                010mm -> scalar l40
                011mm -> v-s l08
                100mm -> v-s l24
                101mm -> v-s l40
                11000 -> scalar LEN l08
                11001 -> scalar LEN l24
                11010 -> scalar LEN l40
                11011 -> v-s LEN l08
                11100 -> v-s LEN l24
                11101 -> v-s LEN l40
                11110 -> IMOD LEN l08
                11111 -> IMOD LEN l24

                (mm is length: 8, 16, 32, 64)
                - l08, l24, l40 are the immediate lengths (in bits)
        }

        [C] |OPCODE(12)|MOD(04)|RD(05)|RS1(05)|IM1(06)| { ok

            - length: 4 bytes always

            MOD(04):

                00mm -> scalar
                01mm -> v-s
                10mm -> //
                1100 -> scalar LEN
                1101 -> v-s LEN
                1110 -> //
                1111 -> IMOD LEN

                (mm is length: 8, 16, 32, 64)
        }

        [D] |OPCODE(05)|MOD(06)|RD(05)|RS1(05)|SH(03)|IM1(08/24/40)| { ok

            - lengths: 4, 6, 8 bytes

            MOD(06):

                me0000 -> 1s select l08
                me0001 -> 1s select l24
                me0010 -> 1s select l40

                me0011 -> 0s select l08
                me0100 -> 0s select l24
                me0101 -> 0s select l40

                me0110 -> 1s ignore l08
                me0111 -> 1s ignore l24
                me1000 -> 1s ignore l40

                me1001 -> 0s ignore l08
                me1010 -> 0s ignore l24
                me1011 -> 0s ignore l40

                (m is mode: 0 scalar, 1 vector)
                (e is extend mode: 0 zero extend, 1 one extend)
        }

        [I] |OPCODE(18)|MOD(04)|RD(05)|RS(05)|

            NOTE: special format used for
                    - vector reductions
                    - casts
                  depending on the category, different MOD tables apply



            - length: 4 bytes always

            MOD(04): (vector reductions)

                d0mm -> integer reduction
                d1mm -> fp. reduction

                (d is direction: forwards or backwards)

            MOD(04): (casts)

                0000 -> 8-16
                0001 -> 8-32
                0010 -> 8-64
                0011 -> 16-8
                0100 -> 16-32
                0101 -> 16-64
                0110 -> 32-8
                0111 -> 32-16
                1000 -> 32-64
                1001 -> 64-8
                1010 -> 64-16
                1011 -> 64-32
    }

    Memory transfer {

        [E] |OPCODE(05)|MOD(04)|RD(05)|RS1(05)|IM1(13/29)| {

            - lengths: 4, 6 bytes

            MOD(04):

                00mm -> scalar l13
                01mm -> scalar l29
                10mm -> scalar l45
                1100 -> vector l13
                1101 -> vector l29
                1110 -> vector l45

                -----------------------

                00mm -> scalar l13
                01mm -> scalar l29
                1000 -> standard vector l13
                1001 -> standard vector l29
                1010 -> stride vector l13
                1011 -> stride vector l29


                (mm is length: 8, 16, 32, 64)
                - l13, l29, l45 are the imm lengths (in bits)
        }

        [F] |OPCODE(05)|MOD(04)|RD(05)|RS1(05)|RS2(05)|IM1(8/24)| {

            - lengths: 4, 6 bytes

            MOD(04):

                00mm -> scalar l08
                01mm -> scalar l24
                1000 -> vector l08 (normal)
                1001 -> vector l24 (normal)
                1010 -> vector l08 (stride)
                1011 -> vector l24 (stride)
        }

        [G] |OPCODE(09)|MOD(03)|RD(05)|RS1(05)|RS2(05)|RS3(05)| {

            - length: 4 bytes only

            MOD(03):

                0mm -> scalar
                100 -> vector
                101 -> stride vector
                110 -> //
                111 -> //

                (mm is length: 8, 16, 32, 64)
        }

        [H] |OPCODE(08)|MOD(02)|RD/RS1(05)|IM1(32)| {

            - length: 6 bytes only

            MOD(02):

                00 -> file_0
                01 -> file_1
                10 -> file_2
                11 -> //

                NOTE: file_n means which register file (see REGISTERS section).
        }

        [J] |OPCODE(10)|MOD(02)|RD(05)|RS1(05)|RS2(05)|RS3(05)| {

            - length: 4 byte only

            MOD(02):

                00 -> scalar-scalar
                01 -> vector-vector
                10 -> scalar-vector
                11 -> vector-scalar
        }
    }

    Control transfer {

        [K] |OPCODE(07)|MOD(03)|RS1(05)|RS2(05)|IM1(12/28)| {

            - lengths: 4, 6 bytes

            MOD(03):

                lmm

                (mm is length: 8, 16, 32, 64)
                - l12, l28, are the imm lengths (in bits)
        }

        [L] |OPCODE(07)|MOD(03)|RS1(05)|IM1(08)|IM2(09/25)| {

            - lengths: 4, 6 bytes

            MOD(03):

                lmm

                (mm is length: 8, 16, 32, 64)
                - l09, l25, are the imm lengths (in bits)
        }

        [M] |OPCODE(07)|MOD(04)|RS1(05)|IM1(16/32)| {

            - lengths: 4, 6 bytes

            MOD(04):

                lfff

                (fff selects the desired flag)
                - l16, l32, are the imm lengths (in bits)
        }
    }

    System {

        ...
    }
}

OPCODE DISTRIBUTION {

    - instructions have variable length opcodes
    - each entry allocates some combinations for its corresponding opcode length
    - needed to understand how to manipulate the opcode
    - the opcode will then signify which format the instruction is

    opcode length of {06}   ->   000000xxxxxx ... 001111xxxxxx   ->  max combinations: (16); current: (12)
    opcode length of {07}   ->   0100000xxxxx ... 1011111xxxxx   ->  max combinations: (64); current: (02)
    opcode length of {08}   ->   11000000xxxx ... 11011111xxxx   ->  max combinations: (32); current: (02)
    opcode length of {09}   ->   111000000xxx ... 111011111xxx   ->  max combinations: (32); current: (22)
    opcode length of {10}   ->   1111000000xx ... 1111011111xx   ->  max combinations: (32); current: (06)
    opcode length of {11}   ->   11111000000x ... 11111011111x   ->  max combinations: (32); current: (44) <<
    opcode length of {12}   ->   111111000000 ... 111111111111   ->  max combinations: (64); current: (11)

    - max: 272 opcodes
    - minimum partition size: 16

    NOTE: x means "don't care"
    NOTE: the distribution above is deprecated, use vvvv

    TODO: make the new distribution
}
______________________________________________________________________________________________________________________________________________________________________

INSTRUCTION LIST

NOTE: some instructions don't use all of the MOD combinations available

Computational {

    arithmetic {

        integer { OK

            [A] (...) Addition--------------------------(?????)
            [A] (...) Subtraction-----------------------(?????)
            [A] (...) Multiplication--------------------(?????)
            [A] (...) Multiply Acc----------------------(?????)
            [A] (...) Division--------------------------(?????)
            [A] (...) Remainder-------------------------(?????)
            [A] (...) Left Shift------------------------(?????)
            [A] (...) Right Shift-----------------------(?????)

            [B] (...) I .Addition-----------------------(?????)
            [B] (...) I .Subtraction--------------------(?????)
            [B] (...) I. Multiplication-----------------(?????)
            [B] (...) I. Multiply Acc-------------------(?????)
            [B] (...) I. Division-----------------------(?????)
            [B] (...) I. Remainder----------------------(?????)
            [C] (...) I. Left Shift---------------------(?????)
            [C] (...) I. Right Shift--------------------(?????)

            [A] (...) Addition Carry--------------------(?????)
        	[A] (...) Subtraction Borrow----------------(?????)
            [A] (...) Carry Left Shift------------------(?????)
        	[A] (...) Carry Right Shift-----------------(?????)
            [A] (...) High Carry Left Shift-------------(?????)
        	[A] (...) High Carry Right Shift------------(?????)
            [A] (...) High Multiplication---------------(?????)
            [A] (...) High Multiply Acc-----------------(?????)
            [A] (...) High Left Shift-------------------(?????)
            [A] (...) High Right Shift------------------(?????)
            [B] (...) I. High Multiplication------------(?????)
            [B] (...) I. High Multiply Acc--------------(?????)
            [C] (...) HI. Left Shift--------------------(?????)
            [C] (...) HI. Right Shift-------------------(?????)
            [C] (...) HI. Carry Left Shift--------------(?????)
        	[C] (...) HI. Carry Right Shift-------------(?????)
            [B] (...) I .Addition Carry-----------------(?????)
        	[B] (...) I .Subtraction Borrow-------------(?????)
        	[C] (...) I. Carry Left Shift---------------(?????)
        	[C] (...) I. Carry Right Shift--------------(?????)
        }

        floating point { OK

            [A] (...) FP. Addition----------------------(?????)
            [A] (...) FP. Subtraction-------------------(?????)
            [A] (...) FP. Multiplication----------------(?????)
            [A] (...) FP. Division----------------------(?????)
            [A] (...) FP. Multiply Acc------------------(?????)
            [A] (...) FP. Nth Root----------------------(?????)

            [B] (...) Imm. FP. Addition-----------------(?????)
            [B] (...) Imm. FP. Subtraction--------------(?????)
            [B] (...) Imm. FP. Multiplication-----------(?????)
            [B] (...) Imm. FP. Division-----------------(?????)
            [B] (...) Imm. FP. Multiply Acc-------------(?????)
        }
    }

    logic { OK

        [A] (...) Left Rotate-----------------------(?????)
        [A] (...) Right Rotate----------------------(?????)
        [A] (...) Bit Swap--------------------------(?????)
        [A] (...) Bitwise AND-----------------------(?????)
        [A] (...) Bitwise NAND----------------------(?????)
        [A] (...) Bitwise OR------------------------(?????)
        [A] (...) Bitwise NOR-----------------------(?????)
        [A] (...) Bitwise XOR-----------------------(?????)
        [A] (...) Bitwise XNOR----------------------(?????)
        [A] (...) Carry-less Multiplication---------(?????)

        [C] (...) I. Left Rotate--------------------(?????)
        [C] (...) I. Right Rotate-------------------(?????)
        [C] (...) I. Bit Swap-----------------------(?????)
        [B] (...) I. Bitwise AND--------------------(?????)
        [B] (...) I. Bitwise NAND-------------------(?????)
        [B] (...) I. Bitwise OR---------------------(?????)
        [B] (...) I. Bitwise NOR--------------------(?????)
        [B] (...) I. Bitwise XOR--------------------(?????)
        [B] (...) I. Bitwise XNOR-------------------(?????)
        [B] (...) I. Carryless Multiplication-------(?????)
    }

    vector reduction {

        ...
    }

    casts {

        [I] (...) Scalar Integer-Integer Cast-------(?????)
        [I] (...) Scalar FP-FP Cast-----------------(?????)
        [I] (...) Vector Integer-Integer Cast-------(?????)
        [I] (...) Vector FP-FP Cast-----------------(?????)
        [I] (...) Scalar Integer-FP Cast------------(?????)
        [I] (...) Scalar FP-Integer Cast------------(?????)
        [I] (...) Vector Integer-FP Cast------------(?????)
        [I] (...) Vector FP-Integer Cast------------(?????)
    }

    miscellaneous { OK

        [D] (...) Get Bit Field---------------------(?????)
        [D] (...) Set Bit Field---------------------(?????)

        [A] (...) Count Ones------------------------(?????)
    	[A] (...) Count Leading Ones----------------(?????)
    	[A] (...) Count Trailing Ones---------------(?????)
    	[A] (...) Count Zeros-----------------------(?????)
    	[A] (...) Count Leading Zeros---------------(?????)
    	[A] (...) Count Trailing Zeros--------------(?????)
    }

    TODO: maybe gather / scatter?
}
______________________________________________________________________________________________________________________________________________________________________

Memory transfer {

    loads & stores {

        [E] (...) Memory Load-----------------------(?????)
        [E] (...) Memory Store----------------------(?????)
        [G] (...) Scaled Memory Load----------------(?????)
        [G] (...) Scaled Memory Store---------------(?????)
        [F] (...) I. Scaled Memory Load-------------(?????)
        [F] (...) I. Scaled Memory Store------------(?????)
    }

    atomic {

        [F] (...) Load Linked-----------------------(?????)
        [F] (...) Store Conditional-----------------(?????)
    }

    moves {

        [J] (...) Cond. Move If True----------------(?????)
        [J] (...) Cond. Move If EQ------------------(?????)
        [J] (...) Cond. Move If NE------------------(?????)
        [J] (...) Cond. Move If LT------------------(?????)
        [J] (...) Cond. Move If GT------------------(?????)
        [J] (...) Cond. Move If LE------------------(?????)
        [J] (...) Cond. Move If GE------------------(?????)

        [J] (...) Cond. FP. Move If True------------(?????)
        [J] (...) Cond. FP. Move If EQ--------------(?????)
        [J] (...) Cond. FP. Move If NE--------------(?????)
        [J] (...) Cond. FP. Move If LT--------------(?????)
        [J] (...) Cond. FP. Move If GT--------------(?????)
        [J] (...) Cond. FP. Move If LE--------------(?????)
        [J] (...) Cond. FP. Move If GE--------------(?????)
    }

    miscellaneous {

        [H] (...) Block Load------------------------(?????)
        [H] (...) Block Store-----------------------(?????)
    }
}
______________________________________________________________________________________________________________________________________________________________________

Control transfer {

    comparison branches {

        integer {

            [K] (...) Branch If EQ----------------------(?????)
            [K] (...) Branch If NE----------------------(?????)
            [K] (...) Branch If LT----------------------(?????)
            [K] (...) Branch If LE----------------------(?????)

            [L] (...) I. Branch If EQ-------------------(?????)
            [L] (...) I. Branch If NE-------------------(?????)
            [L] (...) I. Branch If LT-------------------(?????)
            [L] (...) I. Branch If LE-------------------(?????)
        }

        floating point {

            [K] (...) FP. Branch If EQ------------------(?????)
            [K] (...) FP. Branch If NE------------------(?????)
            [K] (...) FP. Branch If LT------------------(?????)
            [K] (...) FP. Branch If LE------------------(?????)

            [L] (...) I. FP. Branch If EQ---------------(?????)
            [L] (...) I. FP. Branch If NE---------------(?????)
            [L] (...) I. FP. Branch If LT---------------(?????)
            [L] (...) I. FP. Branch If LE---------------(?????)
        }
    }

    flag branches {

        [M] (...) Branch If Flag--------------------(?????)
    }

    calls {

        ...
    }
}
______________________________________________________________________________________________________________________________________________________________________

System {

    [?] (...)  No Operation---------------------(?????)
    [?] (...)  User Event Return----------------(?????)
  * [?] (...)  Supervisor Event Return----------(?????)
    [?] (...)  Fence Loads----------------------(?????)
    [?] (...)  Fence Stores---------------------(?????)
    [?] (...)  Fence Loads and Stores-----------(?????)
    [?] (...)  Fence Instructions---------------(?????)
    [?] (...)  Transaction Begin----------------(?????)
    [?] (...)  Transaction End------------------(?????)
    [?] (...)  Transaction Abort----------------(?????)
    [?] (...)  Transaction Check----------------(?????)

  * [?] (...)  Move Special Register------------(?????)
  * [?] (...)  Cache Operation------------------(?????)
  * [?] (...)  TLB Operation--------------------(?????)
  * [?] (...)  Manipulate Special Register------(?????)
    [?] (...)  System Call----------------------(?????)
    [?] (...)  Wait For Interrupt---------------(?????)
    [?] (...)  Breakpoint Trigger---------------(?????)
}
______________________________________________________________________________________________________________________________________________________________________

REGISTERS {

    file 0 {

        - 32 scalar general purpose registers
        - integer & floating point are shared

        $00--------(FNP_00 "function parameter 00")
		$01--------(FNP_01 "function parameter 01")
		$02--------(FNP_02 "function parameter 02")
		$03--------(FNP_03 "function parameter 03")

		$04--------(FNR_00 "function return value 00")
		$05--------(FNR_01 "function return value 01")

		$06--------(SVR_00 "saved register 00")
		$07--------(SVR_01 "saved register 01")
		$08--------(SVR_02 "saved register 02")
		$09--------(SVR_03 "saved register 03")
		$10--------(SVR_04 "saved register 04")
		$11--------(SVR_05 "saved register 05")
		$12--------(SVR_06 "saved register 06")
		$13--------(SVR_07 "saved register 07")
		$14--------(SVR_08 "saved register 08")
		$15--------(SVR_09 "saved register 09")
		$16--------(SVR_10 "saved register 10")
		$17--------(SVR_11 "saved register 11")
		$18--------(SVR_12 "saved register 12")
		$19--------(SVR_13 "saved register 13")
		$20--------(SVR_14 "saved register 14")
		$21--------(SVR_15 "saved register 15")
		$22--------(SVR_16 "saved register 16")
		$23--------(SVR_17 "saved register 17")

		$24--------(TMP_04 "temporary register 04")
		$25--------(TMP_05 "temporary register 05")
		$26--------(TMP_06 "temporary register 06")
		$27--------(TMP_07 "temporary register 07")

		$28--------(GP "global pointer")
		$29--------(RET "return address")
		$30--------(SP "stack pointer")
		$31--------(FP "frame pointer")
    }

    file 1 {

        - 32 vector general purpose registers (128-512 bits wide)
        - integer & floating point are shared

        &00----(VGPR00 "vector general purpose register 00")
        &01----(VGPR01 "vector general purpose register 01")
        &02----(VGPR02 "vector general purpose register 02")
        &03----(VGPR03 "vector general purpose register 03")
        &04----(VGPR04 "vector general purpose register 04")
        &05----(VGPR05 "vector general purpose register 05")
        &06----(VGPR06 "vector general purpose register 06")
        &07----(VGPR07 "vector general purpose register 07")
        &08----(VGPR08 "vector general purpose register 08")
        &09----(VGPR09 "vector general purpose register 09")
        &10----(VGPR10 "vector general purpose register 10")
        &11----(VGPR11 "vector general purpose register 11")
        &12----(VGPR12 "vector general purpose register 12")
        &13----(VGPR13 "vector general purpose register 13")
        &14----(VGPR14 "vector general purpose register 14")
        &15----(VGPR15 "vector general purpose register 15")
        &16----(VGPR16 "vector general purpose register 16")
        &17----(VGPR17 "vector general purpose register 17")
        &18----(VGPR18 "vector general purpose register 18")
        &19----(VGPR19 "vector general purpose register 19")
        &20----(VGPR20 "vector general purpose register 20")
        &21----(VGPR21 "vector general purpose register 21")
        &22----(VGPR22 "vector general purpose register 22")
        &23----(VGPR23 "vector general purpose register 23")
        &24----(VGPR24 "vector general purpose register 24")
        &25----(VGPR25 "vector general purpose register 25")
        &26----(VGPR26 "vector general purpose register 26")
        &27----(VGPR27 "vector general purpose register 27")
        &28----(VGPR28 "vector general purpose register 28")
        &29----(VGPR29 "vector general purpose register 29")
        &30----(VGPR30 "vector general purpose register 30")
        &31----(VGPR31 "vector general purpose register 31")
    }

    file 2 {

        %00----(TMP_05 "temporary register 05")
        %01----(TMP_06 "temporary register 06")
        %02----(TMP_07 "temporary register 07")
        %03----(TMP_08 "temporary register 08")
        %04----(TMP_09 "temporary register 09")
        %05----(TMP_10 "temporary register 10")
        %06----(TMP_11 "temporary register 11")
        %07----(TMP_12 "temporary register 12")

        %08----(BPR_00 "breakpoint register 00")
        %09----(BPR_01 "breakpoint register 01")
        %10----(BPR_02 "breakpoint register 02")
        %11----(BPR_03 "breakpoint register 03")
        %12----(BPR_04 "breakpoint register 04")
        %13----(BPR_05 "breakpoint register 05")
        %14----(BPR_06 "breakpoint register 06")
        %15----(BPR_07 "breakpoint register 07")

        %16----(BPM "breakpoint modes")
        %17----(VMSK "vector mask")

        %18----(PC "program counter")
        %19----(UPC "user program counter")
        %20----(UCSR "user control & status register")
        %21----(VFLG "vector flags")

      * %22----(CSR "control & status register")
      * %23----(SPC "supervisor program counter")
      * %24----(SCSR "supervisor control & status register")
      * %25----(K0 "kernel temporary 0")
      * %26----(K1 "kernel temporary 1")
      * %27----(ETP "event table pointer")
      * %28----(PTP "page table pointer")

        %29----
        %30----
        %31----
    }

    CSR bit layout {

        - COVR (1) flag
        - CUND (1) flag
        - OVFL (1) flag
        - UNFL (1) flag
        - DIV0 (1) flag
        - ???? (1) flag
        - ???? (1) flag
        - ???? (1) flag

        - LEN (2) (data type length)
        - IMOD (3) (instruction mode, see table below)
        - RMD (2) (rounding modes)
        - TD (8) (transaction nesting depth counter)

        - SUPERVISOR MODE                   (1)
		- CONSISTENCY MODE                  (1)
		- BOOT MODE                         (1)
		- ENABLE PAGING                     (1)
		- ENABLE AUTO EXCEPTIONS            (1)
		- ENABLE USER INTERRUPTS            (1)
		- ENABLE SUPERVISOR INTERRUPTS      (1)
		- EVENT TRIGGERED                   (1)
		- HALT EXECUTION                    (1)

        - PID (32)
    }

    IMOD(3):

        000 -> scalar int
        001 -> vector-vector int
        010 -> vector-scalar int
        011 -> reduction int
        100 -> scalar fp
        101 -> vector-vector fp
        110 -> vector-scalar fp
        111 -> reduction fp
}
______________________________________________________________________________________________________________________________________________________________________
