final ISA version (i hope...)

FORMATS {

    NOTE: not normalized

    Computational {

        (ALU r-r) {

            A |OPCODE(11)|MOD(06)|RD(05)|RS1(05)|RS2(05)|

                MOD(06):

                    s000mm -> scalar
                    s001mm -> v-v
                    s010mm -> v-s
                    s011mm -> reduction
                    s10000 -> scalar LEN
                    s10001 -> v-v LEN
                    s10010 -> v-s LEN
                    s10011 -> reduction LEN
                    s10100 -> IMOD LEN

                    (mm is length: 8, 16, 32, 64)
                    (s is sign mode)
                    - LEN = length specifier
                    - IMOD = instruction mode specifier

                    NOTE: reduction mode only uses RD & RS1. RS2 will be ignored
        }

        (ALU r-i) {

            B |OPCODE(09)|MOD(05)|RD(05)|RS1(05)|IM1(08/24/40)| ok

                MOD(05):

                    000mm -> scalar l08
                    001mm -> scalar l24
                    010mm -> scalar l40
                    011mm -> v-s l08
                    100mm -> v-s l24
                    101mm -> v-s l40
                    11000 -> scalar LEN l08
                    11001 -> scalar LEN l24
                    11010 -> scalar LEN l40
                    11011 -> v-s LEN l08
                    11100 -> v-s LEN l24
                    11101 -> v-s LEN l40
                    11110 -> IMOD LEN l08
                    11111 -> IMOD LEN l24

                    (mm is length: 8, 16, 32, 64)
                    - LEN = length specifier
                    - IMOD = instruction mode specifier
                    - l08, l24, l40 are the imm lengths (in bits)

            C |OPCODE(12)|MOD(04)|RD(05)|RS1(05)|IM1(06)|

                MOD(04):

                    00mm -> scalar
                    01mm -> v-s
                    10mm -> //
                    1100 -> scalar LEN
                    1101 -> v-s LEN
                    1110 -> //
                    1111 -> IMOD LEN

                    (mm is length: 8, 16, 32, 64)
                    - LEN = length specifier
                    - IMOD = instruction mode specifier

                    NOTE: // means unused

            D |OPCODE(07)|MOD(04)|RD(05)|RS1(05)|SH(03)|IMM(08/24/40)|

                MOD(07):

                    m000 -> [1s set, zero extend]
                    m001 -> [1s set, one  extend]
                    m010 -> [0s set, zero extend]
                    m011 -> [0s set, one  extend]
                    m100 -> [1s clear, zero extend]
                    m101 -> [1s clear, one  extend]
                    m110 -> [0s clear, zero extend]
                    m111 -> [0s clear, one  extend]

                    (m is mode: 0 scalar, 1 vector)
        }

        ...
    }

    Memory transfer {

        ...
    }
}

OPCODE DISTRIBUTION {

    000000xxxxxx ... 001111xxxxxx 16
    0100000xxxxx ... 1011111xxxxx 64
    11000000xxxx ... 11011111xxxx 32
    111000000xxx ... 111011111xxx 32
    1111000000xx ... 1111011111xx 32
    11111000000x ... 11111011111x 32
    111111000000 ... 111111111111 64

    max: 272 opcodes
}
______________________________________________________________________________________________________________________________________________________________________
instruction list

NOTE: some instructions don't use all of the MOD combinations available

Computational {

    arithmetic {

        integer { OK

            [A] (...) Addition--------------------------(?????)
            [A] (...) Subtraction-----------------------(?????)
            [A] (...) Multiplication--------------------(?????)
            [A] (...) Multiply Acc----------------------(?????)
            [A] (...) Division--------------------------(?????)
            [A] (...) Remainder-------------------------(?????)
            [A] (...) Left Shift------------------------(?????)
            [A] (...) Right Shift-----------------------(?????)

            [B] (...) I .Addition-----------------------(?????)
            [B] (...) I .Subtraction--------------------(?????)
            [B] (...) I. Multiplication-----------------(?????)
            [B] (...) I. Multiply Acc-------------------(?????)
            [B] (...) I. Division-----------------------(?????)
            [B] (...) I. Remainder----------------------(?????)
            [C] (...) I. Left Shift---------------------(?????)
            [C] (...) I. Right Shift--------------------(?????)

            [A] (...) Addition Carry--------------------(?????)
        	[A] (...) Subtraction Borrow----------------(?????)
            [A] (...) Carry Left Shift------------------(?????)
        	[A] (...) Carry Right Shift-----------------(?????)
            [A] (...) High Carry Left Shift-------------(?????)
        	[A] (...) High Carry Right Shift------------(?????)
            [A] (...) High Multiplication---------------(?????)
            [A] (...) High Multiply Acc-----------------(?????)
            [A] (...) High Left Shift-------------------(?????)
            [A] (...) High Right Shift------------------(?????)
            [B] (...) I. High Multiplication------------(?????)
            [B] (...) I. High Multiply Acc--------------(?????)
            [C] (...) HI. Left Shift--------------------(?????)
            [C] (...) HI. Right Shift-------------------(?????)
            [C] (...) HI. Carry Left Shift--------------(?????)
        	[C] (...) HI. Carry Right Shift-------------(?????)
            [B] (...) I .Addition Carry-----------------(?????)
        	[B] (...) I .Subtraction Borrow-------------(?????)
        	[C] (...) I. Carry Left Shift---------------(?????)
        	[C] (...) I. Carry Right Shift--------------(?????)
        }

        floating point { OK

            [A] (...) FP. Addition----------------------(?????)
            [A] (...) FP. Subtraction-------------------(?????)
            [A] (...) FP. Multiplication----------------(?????)
            [A] (...) FP. Division----------------------(?????)
            [A] (...) FP. Multiply Acc------------------(?????)
            [A] (...) FP. Nth Root----------------------(?????)

            [B] (...) Imm. FP. Addition-----------------(?????)
            [B] (...) Imm. FP. Subtraction--------------(?????)
            [B] (...) Imm. FP. Multiplication-----------(?????)
            [B] (...) Imm. FP. Division-----------------(?????)
            [B] (...) Imm. FP. Multiply Acc-------------(?????)
        }
    }

    logic { OK

        [A] (...) Left Rotate-----------------------(?????)
        [A] (...) Right Rotate----------------------(?????)
        [A] (...) Bit Swap--------------------------(?????)
        [A] (...) Bitwise AND-----------------------(?????)
        [A] (...) Bitwise NAND----------------------(?????)
        [A] (...) Bitwise OR------------------------(?????)
        [A] (...) Bitwise NOR-----------------------(?????)
        [A] (...) Bitwise XOR-----------------------(?????)
        [A] (...) Bitwise XNOR----------------------(?????)
        [A] (...) Carry-less Multiplication---------(?????)

        [C] (...) I. Left Rotate--------------------(?????)
        [C] (...) I. Right Rotate-------------------(?????)
        [C] (...) I. Bit Swap-----------------------(?????)
        [B] (...) I. Bitwise AND--------------------(?????)
        [B] (...) I. Bitwise NAND-------------------(?????)
        [B] (...) I. Bitwise OR---------------------(?????)
        [B] (...) I. Bitwise NOR--------------------(?????)
        [B] (...) I. Bitwise XOR--------------------(?????)
        [B] (...) I. Bitwise XNOR-------------------(?????)
        [B] (...) I. Carryless Multiplication-------(?????)
    }

    miscellaneous {

        [D] (...) Get Bit Field---------------------(?????)
        [D] (...) Set Bit Field---------------------(?????)

        [A] (...) Count Ones------------------------(?????)
    	[A] (...) Count Leading Ones----------------(?????)
    	[A] (...) Count Trailing Ones---------------(?????)
    	[A] (...) Count Zeros-----------------------(?????)
    	[A] (...) Count Leading Zeros---------------(?????)
    	[A] (...) Count Trailing Zeros--------------(?????)
    }
}
______________________________________________________________________________________________________________________________________________________________________

Memory transfer {

    ...
}
______________________________________________________________________________________________________________________________________________________________________

Control transfer {

    ...
}
______________________________________________________________________________________________________________________________________________________________________

System {

    ...
}
______________________________________________________________________________________________________________________________________________________________________
______________________________________________________________________________________________________________________________________________________________________

REGISTERS {

    $00----(GPR00 "general purpose register")
    $01----(GPR01 "general purpose register")
    $02----(GPR02 "general purpose register")
    $03----(GPR03 "general purpose register")
    $04----(GPR04 "general purpose register")
    $05----(GPR05 "general purpose register")
    $06----(GPR06 "general purpose register")
    $07----(GPR07 "general purpose register")
    $08----(GPR08 "general purpose register")
    $09----(GPR09 "general purpose register")
    $10----(GPR10 "general purpose register")
    $11----(GPR11 "general purpose register")
    $12----(GPR12 "general purpose register")
    $13----(GPR13 "general purpose register")
    $14----(GPR14 "general purpose register")
    $15----(GPR15 "general purpose register")
    $16----(GPR16 "general purpose register")
    $17----(GPR17 "general purpose register")
    $18----(GPR18 "general purpose register")
    $19----(GPR19 "general purpose register")
    $20----(GPR20 "general purpose register")
    $21----(GPR21 "general purpose register")
    $22----(GPR22 "general purpose register")
    $23----(GPR23 "general purpose register")
    $24----(GPR24 "general purpose register")
    $25----(GPR25 "general purpose register")
    $26----(GPR26 "general purpose register")
    $27----(GPR27 "general purpose register")
    $28----(GPR28 "general purpose register")
    $29----(GPR29 "general purpose register")
    $30----(GPR30 "general purpose register")
    $31----(GPR31 "general purpose register")

    ---------------------------------------

    %00----(GPR32 "general purpose register")
    %01----(GPR33 "general purpose register")
    %02----(GPR34 "general purpose register")
    %03----(GPR35 "general purpose register")
    %04----(GPR36 "general purpose register")
    %05----(GPR37 "general purpose register")
    %06----(GPR38 "general purpose register")
    %07----(GPR39 "general purpose register")

    %08----(BPR0 "breakpoint register 0")
    %09----(BPR1 "breakpoint register 1")
    %10----(BPR2 "breakpoint register 2")
    %11----(BPR3 "breakpoint register 3")
    %12----(BPR4 "breakpoint register 4")
    %13----(BPR5 "breakpoint register 5")
    %14----(BPR6 "breakpoint register 6")
    %15----(BPR7 "breakpoint register 7")

    %16----(BPM "breakpoint modes")
    %17----(VMSK "vector mask")

    %18----(PC "program counter")
    %19----(UPC "user program counter")
    %20----(UCSR "user control & status register")
    %21----(VFLG "vector flags")

  * %22----(CSR "control & status register")
  * %23----(SPC "supervisor program counter")
  * %24----(SCSR "supervisor control & status register")
  * %25----(K0 "kernel temporary 0")
  * %26----(K1 "kernel temporary 1")
  * %27----(ETP "event table pointer")
  * %28----(PTP "page table pointer")
  * %29----(PID "process identifier")
    %30----
    %31----

    scalar registers are 64 divided into two banks 32 each: one general purpose and the other special purpose. They share integer and floating-point.
    vector registers are 32 and will have a fixed size of 128, 256 or 512. They share integer and floating point.
}
