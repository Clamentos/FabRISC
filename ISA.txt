final ISA version (i hope...)
this is just a quick text file, the fancy PDF is on the way...
______________________________________________________________________________________________________________________________________________________________________

INSTRUCTION FORMATS {

    NOTE: these formats are not normalized, the bits are not in their optimal position
    NOTE: the instructions are listed with: [format] + (mnemonic) + "name" + (altered flags) + {opcode combination}
    NOTE: // means unused
    NOTE: * indicates a privileged resource

    quick acronym legend:

        - MOD -> "mode"
        - RD -> "register destination"
        - RSn -> "register source n"
        - OPCODE -> "operation code"
        - IMn -> "immediate n"
        - LEN -> length specifier (see CSR bit layout in the REGISTERS section)
        - IMOD -> instruction mode specifier (see CSR bit layout in the REGISTERS section)

    NOTE: numbers in parentheses specifies the length of the particular field (in bits)

    Computational {

        [A] |OPCODE(13)|MOD(04)|RD(05)|RS1(05)|RS2(05)| { OK

            - length: 4 bytes always

            MOD(04):

                00mm -> scalar
                01mm -> vector-vector
                10mm -> vector-scalar
                1100 -> scalar LEN
                1101 -> vector-vector LEN
                1110 -> vector-scalar LEN
                1111 -> IMOD LEN

                (mm is length: 8, 16, 32, 64)
        }

        [B] |OPCODE(09)|MOD(05)|RD(05)|RS1(05)|IM1(08/24/40)| { OK

            - lengths: 4, 6, 8 bytes

            MOD(05):

                000mm -> scalar l08
                001mm -> scalar l24
                010mm -> scalar l40
                011mm -> v-s l08
                100mm -> v-s l24
                101mm -> v-s l40
                11000 -> scalar LEN l08
                11001 -> scalar LEN l24
                11010 -> scalar LEN l40
                11011 -> v-s LEN l08
                11100 -> v-s LEN l24
                11101 -> v-s LEN l40
                11110 -> IMOD LEN l08
                11111 -> IMOD LEN l24

                (mm is length: 8, 16, 32, 64)
                - l08, l24, l40 are the immediate lengths (in bits)
        }

        [C] |OPCODE(12)|MOD(04)|RD(05)|RS1(05)|IM1(06)| { OK

            - length: 4 bytes always

            MOD(04):

                00mm -> scalar
                01mm -> v-s
                10mm -> //
                1100 -> scalar LEN
                1101 -> v-s LEN
                1110 -> //
                1111 -> IMOD LEN

                (mm is length: 8, 16, 32, 64)
        }

        [D] |OPCODE(05)|MOD(06)|RD(05)|RS1(05)|SH(03)|IM1(08/24/40)| { OK

            - lengths: 4, 6, 8 bytes

            MOD(06):

                me0000 -> 1s select l08
                me0001 -> 1s select l24
                me0010 -> 1s select l40

                me0011 -> 0s select l08
                me0100 -> 0s select l24
                me0101 -> 0s select l40

                me0110 -> 1s ignore l08
                me0111 -> 1s ignore l24
                me1000 -> 1s ignore l40

                me1001 -> 0s ignore l08
                me1010 -> 0s ignore l24
                me1011 -> 0s ignore l40

                (m is mode: 0 scalar, 1 vector)
                (e is extend mode: 0 zero extend, 1 one extend)
        }

        [I] |OPCODE(18)|MOD(04)|RD(05)|RS(05)| { OK

            NOTE: special format used for
                    - vector reductions
                    - casts
                  depending on the category, different MOD tables apply



            - length: 4 bytes always

            MOD(04): (vector reductions)

                d0mm -> integer reduction
                d1mm -> fp. reduction

                (d is direction: forwards or backwards)

            MOD(04): (casts)

                0000 -> 8-16
                0001 -> 8-32
                0010 -> 8-64
                0011 -> 16-8
                0100 -> 16-32
                0101 -> 16-64
                0110 -> 32-8
                0111 -> 32-16
                1000 -> 32-64
                1001 -> 64-8
                1010 -> 64-16
                1011 -> 64-32
        }
    }

    Memory transfer {

        [E] |OPCODE(05)|MOD(04)|RD(05)|RS1(05)|IM1(13/29)| { OK

            - lengths: 4, 6 bytes

            MOD(04):

                00mm -> scalar l13
                01mm -> scalar l29
                1000 -> standard vector l13
                1001 -> standard vector l29
                1010 -> stride vector l13
                1011 -> stride vector l29

                (mm is length: 8, 16, 32, 64)
                - l13, l29 are the imm lengths (in bits)
        }

        [F] |OPCODE(05)|MOD(04)|RD(05)|RS1(05)|RS2(05)|IM1(8/24)| { OK

            - lengths: 4, 6 bytes

            MOD(04):

                00mm -> scalar l08
                01mm -> scalar l24
                1000 -> vector l08
                1001 -> vector l24
                1010 -> stride vector l08
                1011 -> stride vector l24
        }

        [G] |OPCODE(09)|MOD(03)|RD(05)|RS1(05)|RS2(05)|RS3(05)| { OK

            - length: 4 bytes only

            MOD(03):

                0mm -> scalar
                100 -> vector
                101 -> stride vector

                (mm is length: 8, 16, 32, 64)
        }

        [H] |OPCODE(08)|MOD(02)|RD/RS1(05)|IM1(32)| { OK

            - length: 6 bytes only

            MOD(02):

                00 -> file_0
                01 -> file_1
                10 -> file_2

                NOTE: file_n means which register file (see REGISTERS section).
        }

        [J] |OPCODE(10)|MOD(02)|RD(05)|RS1(05)|RS2(05)|RS3(05)| { OK

            - length: 4 byte only

            MOD(02):

                00 -> scalar-scalar
                01 -> vector-vector
                10 -> scalar-vector
                11 -> vector-scalar
        }
    }

    Control transfer {

        [K] |OPCODE(07)|MOD(03)|RS1(05)|RS2(05)|IM1(12/28)| {

            - lengths: 4, 6 bytes

            MOD(03):

                lmm

                (mm is length: 8, 16, 32, 64)
                - l12, l28, are the imm lengths (in bits)
        }

        [L] |OPCODE(07)|MOD(03)|RS1(05)|IM1(08)|IM2(09/25)| {

            - lengths: 4, 6 bytes

            MOD(03):

                lmm

                (mm is length: 8, 16, 32, 64)
                - l09, l25, are the imm lengths (in bits)
        }

        [M] |OPCODE(07)|MOD(04)|RS1(05)|IM1(16/32)| {

            - lengths: 4, 6 bytes

            MOD(04):

                lfff

                (fff selects the desired flag)
                - l16, l32, are the imm lengths (in bits)
        }

        [O] |OPCODE(07)|MOD(01)|RD(05)|IMM(19/35)| {

            - lengths: 4, 6 bytes

            MOD(01):

                0 -> l19
                1 -> l35
        }

        [P] |OPCODE(07)|MOD(01)|RD(05)|RS1(05)|IMM(14/30)| {

            - lengths: 4, 6 bytes

            MOD(01):

                0 -> l14
                1 -> l30
        }
    }

    System {

        ...
    }

    Compressed {

        [P] |OPCODE(08)|MOD(02)|RD/RS1(03)|RS2(03)| {

            - length: 2 byte always

            MOD(02):

                mm

                (mm is length: 8, 16, 32, 64)
        }

        [Q] |OPCODE(07)|RS1(03)|IM1(06)| {

            - length: 2 byte always
        }

        [R] |OPCODE(08)|IM1(08)| {

            - length: 2 byte always
        }
    }
}

OPCODE DISTRIBUTION {

    - instructions have variable length opcodes
    - each entry allocates some combinations for its corresponding opcode length
    - needed to understand how to manipulate the opcode
    - the opcode will then signify which format the instruction is

    opcode length(05) 00000xxxxxxxxxxxxx ... 00111xxxxxxxxxxxxx -> max amount: 08, current: 08 [100 %]
    opcode length(07) 0100000xxxxxxxxxxx ... 1011111xxxxxxxxxxx -> max amount: 64, current: 45 [70  %]
    opcode length(08) 11000000xxxxxxxxxx ... 11011111xxxxxxxxxx -> max amount: 32, current: 10 [31  %]
    opcode length(09) 111000000xxxxxxxxx ... 111011111xxxxxxxxx -> max amount: 32, current: 24 [75  %]
    opcode length(10) 1111000000xxxxxxxx ... 1111011111xxxxxxxx -> max amount: 32, current: 14 [43  %]
    opcode length(12) 111110000000xxxxxx ... 111110011111xxxxxx -> max amount: 32, current: 15 [46  %]
    opcode length(13) 1111101000000xxxxx ... 1111101111111xxxxx -> max amount: 64, current: 46 [71  %]
    opcode length(18) 111111000000000000 ... 111111000000011111 -> max amount: 32, current: 28 [87  %]

    - max: ??? opcodes

    NOTE: x means "don't care"
}
______________________________________________________________________________________________________________________________________________________________________

INSTRUCTION LIST

Computational {

    arithmetic {

        integer { OK

            [A] (...) Addition--------------------------(?????)
            [A] (...) Subtraction-----------------------(?????)
            [A] (...) Multiplication--------------------(?????)
            [A] (...) Multiply Acc----------------------(?????)
            [A] (...) Division--------------------------(?????)
            [A] (...) Remainder-------------------------(?????)
            [A] (...) Arithmetic Left Shift-------------(?????)
            [A] (...) Arithmetic Right Shift------------(?????)

            [B] (...) I .Addition-----------------------(?????)
            [B] (...) I .Subtraction--------------------(?????)
            [B] (...) I. Multiplication-----------------(?????)
            [B] (...) I. Multiply Acc-------------------(?????)
            [B] (...) I. Division-----------------------(?????)
            [B] (...) I. Remainder----------------------(?????)
            [C] (...) I. Arithmetic Left Shift----------(?????)
            [C] (...) I. Arithmetic Right Shift---------(?????)

            [A] (...) Addition Carry--------------------(?????)
        	[A] (...) Subtraction Borrow----------------(?????)
            [A] (...) Carry Arithmetic Left Shift-------(?????)
        	[A] (...) Carry Arithmetic Right Shift------(?????)
            [A] (...) High Multiplication---------------(?????)
            [A] (...) High Multiply Acc-----------------(?????)
            [A] (...) High Arithmetic Left Shift--------(?????)
            [A] (...) High Arithmetic Right Shift-------(?????)
            [B] (...) I. High Multiplication------------(?????)
            [B] (...) I. High Multiply Acc--------------(?????)
            [C] (...) HI. Arithmetic Left Shift---------(?????)
            [C] (...) HI. Arithmetic Right Shift--------(?????)
            [B] (...) I .Addition Carry-----------------(?????)
        	[B] (...) I .Subtraction Borrow-------------(?????)
        	[C] (...) I. Arithmetic Carry Left Shift----(?????)
        	[C] (...) I. Arithmetic Carry Right Shift---(?????)
        }

        floating point { OK

            [A] (...) FP. Addition----------------------(?????)
            [A] (...) FP. Subtraction-------------------(?????)
            [A] (...) FP. Multiplication----------------(?????)
            [A] (...) FP. Division----------------------(?????)
            [A] (...) FP. Multiply Acc------------------(?????)
            [A] (...) FP. Nth Root----------------------(?????)

            [B] (...) Imm. FP. Addition-----------------(?????)
            [B] (...) Imm. FP. Subtraction--------------(?????)
            [B] (...) Imm. FP. Multiplication-----------(?????)
            [B] (...) Imm. FP. Division-----------------(?????)
            [B] (...) Imm. FP. Multiply Acc-------------(?????)
        }
    }

    logic { OK

        [A] (...) Logical Left Shift----------------(?????)
        [A] (...) Logical Right Shift---------------(?????)
        [A] (...) Left Rotate-----------------------(?????)
        [A] (...) Right Rotate----------------------(?????)
        [A] (...) Bit Swap--------------------------(?????)
        [A] (...) Bitwise AND-----------------------(?????)
        [A] (...) Bitwise NAND----------------------(?????)
        [A] (...) Bitwise OR------------------------(?????)
        [A] (...) Bitwise NOR-----------------------(?????)
        [A] (...) Bitwise XOR-----------------------(?????)
        [A] (...) Bitwise XNOR----------------------(?????)
        [A] (...) Carry-less Multiplication---------(?????)

        [C] (...) I. Logical Left Shift-------------(?????)
        [C] (...) I. Logical Right Shift------------(?????)
        [C] (...) I. Left Rotate--------------------(?????)
        [C] (...) I. Right Rotate-------------------(?????)
        [C] (...) I. Bit Swap-----------------------(?????)
        [B] (...) I. Bitwise AND--------------------(?????)
        [B] (...) I. Bitwise NAND-------------------(?????)
        [B] (...) I. Bitwise OR---------------------(?????)
        [B] (...) I. Bitwise NOR--------------------(?????)
        [B] (...) I. Bitwise XOR--------------------(?????)
        [B] (...) I. Bitwise XNOR-------------------(?????)
        [B] (...) I. Carryless Multiplication-------(?????)

        [A] (...) Carry Logical Left Shift----------(?????)
        [A] (...) Carry Logical Right Shift---------(?????)
        [A] (...) High Logical Left Shift-----------(?????)
        [A] (...) High Logical Right Shift----------(?????)
        [C] (...) HI. Logical Left Shift------------(?????)
        [C] (...) HI. Logical Right Shift-----------(?????)
        [C] (...) I. Logical Carry Left Shift-------(?????)
        [C] (...) I. Logical Carry Right Shift------(?????)
    }

    vector reduction { OK

        [I] (...) Reduced Addition------------------(?????)
        [I] (...) Reduced Forward Subtraction-------(?????)
        [I] (...) Reduced Backward Subtraction------(?????)
        [I] (...) Reduced Multiplication------------(?????)
        [I] (...) Reduced Multiply Acc--------------(?????)
        [I] (...) Reduced Forward Division----------(?????)
        [I] (...) Reduced Backward Division---------(?????)

        [I] (...) Reduced FP. Addition--------------(?????)
        [I] (...) Reduced FP. Forward Subtraction---(?????)
        [I] (...) Reduced FP. Backward Subtraction--(?????)
        [I] (...) Reduced FP. Multiplication--------(?????)
        [I] (...) Reduced FP. Multiply Acc----------(?????)
        [I] (...) Reduced FP. Forward Division------(?????)
        [I] (...) Reduced FP. Backward Division-----(?????)

        [I] (...) Reduced Bitwise AND---------------(?????)
        [I] (...) Reduced Bitwise NAND--------------(?????)
        [I] (...) Reduced Bitwise OR----------------(?????)
        [I] (...) Reduced Bitwise NOR---------------(?????)
        [I] (...) Reduced Bitwise XOR---------------(?????)
        [I] (...) Reduced Bitwise XNOR--------------(?????)
    }

    casts { OK

        [I] (...) Scalar Integer-Integer Cast-------(?????)
        [I] (...) Scalar FP-FP Cast-----------------(?????)
        [I] (...) Vector Integer-Integer Cast-------(?????)
        [I] (...) Vector FP-FP Cast-----------------(?????)
        [I] (...) Scalar Integer-FP Cast------------(?????)
        [I] (...) Scalar FP-Integer Cast------------(?????)
        [I] (...) Vector Integer-FP Cast------------(?????)
        [I] (...) Vector FP-Integer Cast------------(?????)
    }

    miscellaneous { OK

        [D] (...) Get Bit Field---------------------(?????)
        [D] (...) Set Bit Field---------------------(?????)

        [A] (...) Count Ones------------------------(?????)
    	[A] (...) Count Leading Ones----------------(?????)
    	[A] (...) Count Trailing Ones---------------(?????)
    	[A] (...) Count Zeros-----------------------(?????)
    	[A] (...) Count Leading Zeros---------------(?????)
    	[A] (...) Count Trailing Zeros--------------(?????)
    }

    TODO: maybe gather / scatter?
}
______________________________________________________________________________________________________________________________________________________________________

Memory transfer {

    loads & stores {

        [E] (...) Memory Load-----------------------(?????)
        [E] (...) Memory Store----------------------(?????)
        [G] (...) Scaled Memory Load----------------(?????)
        [G] (...) Scaled Memory Store---------------(?????)
        [F] (...) I. Scaled Memory Load-------------(?????)
        [F] (...) I. Scaled Memory Store------------(?????)
    }

    atomic {

        [F] (...) Load Linked-----------------------(?????)
        [F] (...) Store Conditional-----------------(?????)
    }

    moves {

        [J] (...) Cond. Move If True----------------(?????)
        [J] (...) Cond. Move If EQ------------------(?????)
        [J] (...) Cond. Move If NE------------------(?????)
        [J] (...) Cond. Move If LT------------------(?????)
        [J] (...) Cond. Move If GT------------------(?????)
        [J] (...) Cond. Move If LE------------------(?????)
        [J] (...) Cond. Move If GE------------------(?????)

        [J] (...) Cond. FP. Move If True------------(?????)
        [J] (...) Cond. FP. Move If EQ--------------(?????)
        [J] (...) Cond. FP. Move If NE--------------(?????)
        [J] (...) Cond. FP. Move If LT--------------(?????)
        [J] (...) Cond. FP. Move If GT--------------(?????)
        [J] (...) Cond. FP. Move If LE--------------(?????)
        [J] (...) Cond. FP. Move If GE--------------(?????)
    }

    miscellaneous {

        [H] (...) Block Load------------------------(?????)
        [H] (...) Block Store-----------------------(?????)
    }
}
______________________________________________________________________________________________________________________________________________________________________

Control transfer {

    comparison branches {

        integer {

            [K] (...) Branch If EQ----------------------(?????)
            [K] (...) Branch If NE----------------------(?????)
            [K] (...) Branch If LT----------------------(?????)
            [K] (...) Branch If LE----------------------(?????)

            [L] (...) I. Branch If EQ-------------------(?????)
            [L] (...) I. Branch If NE-------------------(?????)
            [L] (...) I. Branch If LT-------------------(?????)
            [L] (...) I. Branch If LE-------------------(?????)
        }

        floating point {

            [K] (...) FP. Branch If EQ------------------(?????)
            [K] (...) FP. Branch If NE------------------(?????)
            [K] (...) FP. Branch If LT------------------(?????)
            [K] (...) FP. Branch If LE------------------(?????)

            [L] (...) I. FP. Branch If EQ---------------(?????)
            [L] (...) I. FP. Branch If NE---------------(?????)
            [L] (...) I. FP. Branch If LT---------------(?????)
            [L] (...) I. FP. Branch If LE---------------(?????)
        }
    }

    flag branches {

        [M] (...) Branch If Flag--------------------(?????)
    }

    calls {

        [O] (...) Function Call---------------------(?????)
        [P] (...) Function Call Register------------(?????)
        [?] (...) Function Return-------------------(?????)
    }
}
______________________________________________________________________________________________________________________________________________________________________

System {

    [?] (...)  No Operation---------------------(?????)
    [?] (...)  User Event Return----------------(?????)
  * [?] (...)  Supervisor Event Return----------(?????)
    [?] (...)  Fence Loads----------------------(?????)
    [?] (...)  Fence Stores---------------------(?????)
    [?] (...)  Fence Loads and Stores-----------(?????)
    [?] (...)  Fence Instructions---------------(?????)
    [?] (...)  Transaction Begin----------------(?????)
    [?] (...)  Transaction End------------------(?????)
    [?] (...)  Transaction Abort----------------(?????)
    [?] (...)  Transaction Check----------------(?????)

  * [?] (...)  Move Special Register------------(?????)
  * [?] (...)  Cache Operation------------------(?????)
  * [?] (...)  TLB Operation--------------------(?????)
  * [?] (...)  Manipulate Special Register------(?????)
    [?] (...)  System Call----------------------(?????)
    [?] (...)  Wait For Interrupt---------------(?????)
    [?] (...)  Breakpoint Trigger---------------(?????)
}
______________________________________________________________________________________________________________________________________________________________________

Compressed {

    [P] (...) Comp. Load
    [P] (...) Comp. Store

    [P] (...) Comp. Addition
    [P] (...) Comp. Subtraction
    [P] (...) Comp. FP Addition
    [P] (...) Comp. FP Subtraction

    [Q] (...) Comp. Addition Immediate_8
    [Q] (...) Comp. Addition Immediate_16
    [Q] (...) Comp. Addition Immediate_32
    [Q] (...) Comp. Addition Immediate_64
    [Q] (...) Comp. Branch If EQZ
    [Q] (...) Comp. Branch If NEZ
    [Q] (...) Comp. Branch if LTZ_8
    [Q] (...) Comp. Branch if LTZ_16
    [Q] (...) Comp. Branch if LTZ_32
    [Q] (...) Comp. Branch if LTZ_64
    [Q] (...) Comp. Branch if LEZ_8
    [Q] (...) Comp. Branch if LEZ_16
    [Q] (...) Comp. Branch if LEZ_32
    [Q] (...) Comp. Branch if LEZ_64
    [Q] (...) Comp. Logical LSH Immediate_8
    [Q] (...) Comp. Logical LSH Immediate_16
    [Q] (...) Comp. Logical LSH Immediate_32
    [Q] (...) Comp. Logical LSH Immediate_64
    [Q] (...) Comp. Logical RSH Immediate_8
    [Q] (...) Comp. Logical RSH Immediate_16
    [Q] (...) Comp. Logical RSH Immediate_32
    [Q] (...) Comp. Logical RSH Immediate_64
    [Q] (...) Comp. Arithmetic RSH Immediate_8
    [Q] (...) Comp. Arithmetic RSH Immediate_16
    [Q] (...) Comp. Arithmetic RSH Immediate_32
    [Q] (...) Comp. Arithmetic RSH Immediate_64

    [R] (...) Comp. Jump
    [Q] (...) Comp. Register Jump
    [R] (...) Comp. Function Call
    [Q] (...) Comp. Register Function Call
}
______________________________________________________________________________________________________________________________________________________________________

REGISTERS {

    file 0 {

        - 32 scalar general purpose registers
        - integer & floating point are shared

        $00--------(FNP_00 "function parameter 00")
		$01--------(FNP_01 "function parameter 01")
		$02--------(FNP_02 "function parameter 02")
		$03--------(FNP_03 "function parameter 03")

		$04--------(FNR_00 "function return value 00")
		$05--------(FNR_01 "function return value 01")

		$06--------(SVR_00 "saved register 00")
		$07--------(SVR_01 "saved register 01")
		$08--------(SVR_02 "saved register 02")
		$09--------(SVR_03 "saved register 03")
		$10--------(SVR_04 "saved register 04")
		$11--------(SVR_05 "saved register 05")
		$12--------(SVR_06 "saved register 06")
		$13--------(SVR_07 "saved register 07")
		$14--------(SVR_08 "saved register 08")
		$15--------(SVR_09 "saved register 09")
		$16--------(SVR_10 "saved register 10")
		$17--------(SVR_11 "saved register 11")
		$18--------(SVR_12 "saved register 12")
		$19--------(SVR_13 "saved register 13")
		$20--------(SVR_14 "saved register 14")
		$21--------(SVR_15 "saved register 15")
		$22--------(SVR_16 "saved register 16")
		$23--------(SVR_17 "saved register 17")

		$24--------(TMP_04 "temporary register 04")
		$25--------(TMP_05 "temporary register 05")
		$26--------(TMP_06 "temporary register 06")
		$27--------(TMP_07 "temporary register 07")

		$28--------(GP "global pointer")
		$29--------(RET "return address")
		$30--------(SP "stack pointer")
		$31--------(FP "frame pointer")

        NOTE: the callee must save any "saved register" that he intends to utilize. This is because the caller expects the "saved registers" to retain
              their value across calls. (callee saved)

        NOTE: the caller must save any "temporary register" before a call if they hold important values. This is because "temporary registers" are not
              expected to retain their value across calls. (caller saved)

        TODO: reorder the regs ABI to improve the power of compressed instructions
    }

    file 1 {

        - 32 vector general purpose registers (128-512 bits wide)
        - integer & floating point are shared

        &00----(VGPR00 "vector general purpose register 00")
        &01----(VGPR01 "vector general purpose register 01")
        &02----(VGPR02 "vector general purpose register 02")
        &03----(VGPR03 "vector general purpose register 03")
        &04----(VGPR04 "vector general purpose register 04")
        &05----(VGPR05 "vector general purpose register 05")
        &06----(VGPR06 "vector general purpose register 06")
        &07----(VGPR07 "vector general purpose register 07")
        &08----(VGPR08 "vector general purpose register 08")
        &09----(VGPR09 "vector general purpose register 09")
        &10----(VGPR10 "vector general purpose register 10")
        &11----(VGPR11 "vector general purpose register 11")
        &12----(VGPR12 "vector general purpose register 12")
        &13----(VGPR13 "vector general purpose register 13")
        &14----(VGPR14 "vector general purpose register 14")
        &15----(VGPR15 "vector general purpose register 15")
        &16----(VGPR16 "vector general purpose register 16")
        &17----(VGPR17 "vector general purpose register 17")
        &18----(VGPR18 "vector general purpose register 18")
        &19----(VGPR19 "vector general purpose register 19")
        &20----(VGPR20 "vector general purpose register 20")
        &21----(VGPR21 "vector general purpose register 21")
        &22----(VGPR22 "vector general purpose register 22")
        &23----(VGPR23 "vector general purpose register 23")
        &24----(VGPR24 "vector general purpose register 24")
        &25----(VGPR25 "vector general purpose register 25")
        &26----(VGPR26 "vector general purpose register 26")
        &27----(VGPR27 "vector general purpose register 27")
        &28----(VGPR28 "vector general purpose register 28")
        &29----(VGPR29 "vector general purpose register 29")
        &30----(VGPR30 "vector general purpose register 30")
        &31----(VGPR31 "vector general purpose register 31")
    }

    file 2 {

        %00----(TMP_05 "temporary register 05")
        %01----(TMP_06 "temporary register 06")
        %02----(TMP_07 "temporary register 07")
        %03----(TMP_08 "temporary register 08")
        %04----(TMP_09 "temporary register 09")
        %05----(TMP_10 "temporary register 10")
        %06----(TMP_11 "temporary register 11")
        %07----(TMP_12 "temporary register 12")

        %08----(BPR_00 "breakpoint register 00")
        %09----(BPR_01 "breakpoint register 01")
        %10----(BPR_02 "breakpoint register 02")
        %11----(BPR_03 "breakpoint register 03")
        %12----(BPR_04 "breakpoint register 04")
        %13----(BPR_05 "breakpoint register 05")
        %14----(BPR_06 "breakpoint register 06")
        %15----(BPR_07 "breakpoint register 07")

        %16----(BPM "breakpoint modes")
        %17----(VMSK "vector mask")

        %18----(PC "program counter")
        %19----(UPC "user program counter")
        %20----(UCSR "user control & status register")
        %21----(VFLG "vector flags")

      * %22----(CSR "control & status register")
      * %23----(SPC "supervisor program counter")
      * %24----(SCSR "supervisor control & status register")
      * %25----(K0 "kernel reserved 0")
      * %26----(K1 "kernel reserved 1")
      * %27----(ETP "event table pointer")
      * %28----(PTP "page table pointer")

        %29----
        %30----
        %31----
    }

    CSR bit layout {

        - COVR (1) flag
        - CUND (1) flag
        - OVFL (1) flag
        - UNFL (1) flag
        - DIV0 (1) flag
        - ???? (1) flag
        - ???? (1) flag
        - ???? (1) flag

        - LEN (2) (data type length)
        - VLEN (?) (vector length)
        - IMOD (3) (instruction mode, see table below)
        - RMD (2) (rounding modes)
        - TD (8) (transaction nesting depth counter)

        - SUPERVISOR MODE                   (1)
		- CONSISTENCY MODE                  (1)
		- BOOT MODE                         (1)
		- ENABLE PAGING                     (1)
		- ENABLE AUTO EXCEPTIONS            (1)
		- ENABLE USER INTERRUPTS            (1)
		- ENABLE SUPERVISOR INTERRUPTS      (1)
		- EVENT TRIGGERED                   (1)
		- HALT EXECUTION                    (1)

        - PID (32)
    }
}
______________________________________________________________________________________________________________________________________________________________________
