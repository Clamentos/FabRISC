final ISA version (i hope...)
this is just a quick text file, the fancy PDF is on the way...
______________________________________________________________________________________________________________________________________________________________________

INSTRUCTION FORMATS {

    NOTE: these formats are not normalized, the bits are not in their optimal position
    NOTE: the instructions are listed with: [format] + (mnemonic) + "name" + (altered flags) + {opcode combination}
    NOTE: // means unused
    NOTE: * indicates a privileged resource

    quick acronym legend:

        - MOD -> "mode"
        - RD -> "register destination"
        - RSn -> "register source n"
        - OPCODE -> "operation code"
        - IMn -> "immediate n"
        - LEN -> length specifier (see CSR bit layout in the REGISTERS section)
        - IMOD -> instruction mode specifier (see CSR bit layout in the REGISTERS section)

    NOTE: numbers in parentheses specifies the length of the particular field (in bits)

    Computational {

        [A] |OPCODE(13)|MOD(04)|RD(05)|RS1(05)|RS2(05)| {

            - length: 4 bytes always

            MOD(04):

                00mm -> scalar
                01mm -> vector-vector
                10mm -> vector-scalar
                1100 -> scalar LEN
                1101 -> vector-vector LEN
                1110 -> vector-scalar LEN
                1111 -> IMOD LEN

                (mm is length: 8, 16, 32, 64)
                (s is sign mode: signed or unsigned)
        }

        [B] |OPCODE(09)|MOD(05)|RD(05)|RS1(05)|IM1(08/24/40)| {

            - lengths: 4, 6, 8 bytes

            MOD(05):

                000mm -> scalar l08
                001mm -> scalar l24
                010mm -> scalar l40
                011mm -> v-s l08
                100mm -> v-s l24
                101mm -> v-s l40
                11000 -> scalar LEN l08
                11001 -> scalar LEN l24
                11010 -> scalar LEN l40
                11011 -> v-s LEN l08
                11100 -> v-s LEN l24
                11101 -> v-s LEN l40
                11110 -> IMOD LEN l08
                11111 -> IMOD LEN l24

                (mm is length: 8, 16, 32, 64)
                - l08, l24, l40 are the immediate lengths (in bits)
        }

        [C] |OPCODE(12)|MOD(04)|RD(05)|RS1(05)|IM1(06)| {

            - lengths: 4 bytes

            MOD(04):

                00mm -> scalar
                01mm -> v-s
                10mm -> //
                1100 -> scalar LEN
                1101 -> v-s LEN
                1110 -> //
                1111 -> IMOD LEN

                (mm is length: 8, 16, 32, 64)
        }

        [D] |OPCODE(07)|MOD(04)|RD(05)|RS1(05)|SH(03)|IM1(08/24/40)| {

            - lengths: 4, 6, 8 bytes

            MOD(04):

                m000 -> [1s set,   zero extend]
                m001 -> [1s set,   one  extend]
                m010 -> [0s set,   zero extend]
                m011 -> [0s set,   one  extend]
                m100 -> [1s clear, zero extend]
                m101 -> [1s clear, one  extend]
                m110 -> [0s clear, zero extend]
                m111 -> [0s clear, one  extend]

                (m is mode: 0 scalar, 1 vector)
        }

        [I] |OPCODE(18)|MOD(04)|RD(05)|RS(05)|    NOTE: used for reduction

            MOD(04):

                00mm -> reduction
                ...

        [J] |OPCODE(07)|MOD(04)|RD/RS(05)| NOTE: used for casts

            MOD(03):

                mmnn
                mmnn
                mmnn
    }

    Memory transfer {

        [E] |OPCODE(06)|MOD(04)|RD(05)|RS1(05)|IM1(12/28/44)| {

            - lengths: 4, 6, 8 bytes

            MOD(04):

                00mm -> scalar l12
                01mm -> scalar l28
                10mm -> scalar l44
                1100 -> vector l12
                1101 -> vector l28
                1110 -> vector l44

                (mm is length: 8, 16, 32, 64)
                - l12, l28, l44 are the imm lengths (in bits)
        }

        [F] |OPCODE(06)|MOD(03)|RD(05)|RS1(05)|RS2(05)|IM1(8/24)| {

            - lengths: 4, 6 bytes

            MOD(03):

                0mm -> l08
                1mm -> l24

                (mm is length: 8, 16, 32, 64)
                - l08, l24 are the imm lengths (in bits)

            ---------------------------------------------------

            WARNING: potential replacement with:

                |OPCODE(05)|MOD(04)|RD(05)|RS1(05)|RS2(05)|IM1(8/24)|

                    MOD(04):

                        00mm -> scalar l08
                        01mm -> scalar l24
                        1000 -> vector l08 (normal)
                        1001 -> vector l24 (normal)
                        1010 -> vector l08 (stride)
                        1011 -> vector l24 (stride)
        }

        [G] |OPCODE(09)|MOD(03)|RD(05)|RS1(05)|RS2(05)|RS3(05)| {

            - length: 4 bytes only

            MOD(03):

                0mm -> scalar
                100 -> vector
                101 -> //
                110 -> //
                111 -> //

                (mm is length: 8, 16, 32, 64)
        }

        [H] |OPCODE(08)|MOD(02)|RD/RS1(05)|IM1(32)|

            - length: 6 bytes only

            MOD(02):

                00 -> file_0
                01 -> file_1
                10 -> file_2
                11 -> //

                NOTE: file_n means which register file (see REGISTERS section).
    }

    Control transfer {

        ...
    }

    System {

        ...
    }
}

OPCODE DISTRIBUTION {

    - instructions have variable length opcodes
    - each entry allocates some combinations for its corresponding opcode length
    - needed to understand how to manipulate the opcode
    - the opcode will then signify which format the instruction is

    opcode length of {06}   ->   000000xxxxxx ... 001111xxxxxx   ->  max combinations: (16); current: (12)
    opcode length of {07}   ->   0100000xxxxx ... 1011111xxxxx   ->  max combinations: (64); current: (02)
    opcode length of {08}   ->   11000000xxxx ... 11011111xxxx   ->  max combinations: (32); current: (02)
    opcode length of {09}   ->   111000000xxx ... 111011111xxx   ->  max combinations: (32); current: (22)
    opcode length of {10}   ->   1111000000xx ... 1111011111xx   ->  max combinations: (32); current: (06)
    opcode length of {11}   ->   11111000000x ... 11111011111x   ->  max combinations: (32); current: (44) <<
    opcode length of {12}   ->   111111000000 ... 111111111111   ->  max combinations: (64); current: (11)

    - max: 272 opcodes
    - minimum partition size: 16

    NOTE: x means "don't care"
    NOTE: the distribution above is deprecated, use vvvv


    ----------------------------------------------------


    000000 xxxxxxxxxxxx ... 001111 xxxxxxxxxxxx 16
    010000 0xxxxxxxxxxx ... 101111 1xxxxxxxxxxx 64
    110000 00xxxxxxxxxx ... 110111 11xxxxxxxxxx 32
    111000 000xxxxxxxxx ... 111011 111xxxxxxxxx 32
    111100 0000xxxxxxxx ... 111101 1111xxxxxxxx 32
    111110 000000xxxxxx ... 111111 111110xxxxxx 63 << (make it 64 by wasting 1 entry)
    111111 111111000000 ... 111111 111111111111 64

    - CU ROM addresses (assumes 1:1 mapping from macro op -> micro op (no sequencing))

    000000000 -> 000001111    6

    000010000 -> 000011111    7
    000100000 -> 000101111    7
    000110000 -> 000111111    7
    001000000 -> 001001111    7

    001010000 -> 001011111    8
    001100000 -> 001101111    8

    001110000 -> 001111111    9
    010000000 -> 010001111    9

    010010000 -> 010011111    10
    010100000 -> 010101111    10

    010110000 -> 010111111    12
    011000000 -> 011001111    12
    011010000 -> 011011111    12
    011100000 -> 011111111    12

    011110000 -> 011111111    18
    100000000 -> 100001111    18
    100010000 -> 100011111    18
    100100000 -> 100101111    18
}
______________________________________________________________________________________________________________________________________________________________________

INSTRUCTION LIST

NOTE: some instructions don't use all of the MOD combinations available

Computational {

    arithmetic {

        integer { OK

            [A] (...) Addition--------------------------(?????)
            [A] (...) Subtraction-----------------------(?????)
            [A] (...) Multiplication--------------------(?????)
            [A] (...) Multiply Acc----------------------(?????)
            [A] (...) Division--------------------------(?????)
            [A] (...) Remainder-------------------------(?????)
            [A] (...) Left Shift------------------------(?????)
            [A] (...) Right Shift-----------------------(?????)

            [B] (...) I .Addition-----------------------(?????)
            [B] (...) I .Subtraction--------------------(?????)
            [B] (...) I. Multiplication-----------------(?????)
            [B] (...) I. Multiply Acc-------------------(?????)
            [B] (...) I. Division-----------------------(?????)
            [B] (...) I. Remainder----------------------(?????)
            [C] (...) I. Left Shift---------------------(?????)
            [C] (...) I. Right Shift--------------------(?????)

            [A] (...) Addition Carry--------------------(?????)
        	[A] (...) Subtraction Borrow----------------(?????)
            [A] (...) Carry Left Shift------------------(?????)
        	[A] (...) Carry Right Shift-----------------(?????)
            [A] (...) High Carry Left Shift-------------(?????)
        	[A] (...) High Carry Right Shift------------(?????)
            [A] (...) High Multiplication---------------(?????)
            [A] (...) High Multiply Acc-----------------(?????)
            [A] (...) High Left Shift-------------------(?????)
            [A] (...) High Right Shift------------------(?????)
            [B] (...) I. High Multiplication------------(?????)
            [B] (...) I. High Multiply Acc--------------(?????)
            [C] (...) HI. Left Shift--------------------(?????)
            [C] (...) HI. Right Shift-------------------(?????)
            [C] (...) HI. Carry Left Shift--------------(?????)
        	[C] (...) HI. Carry Right Shift-------------(?????)
            [B] (...) I .Addition Carry-----------------(?????)
        	[B] (...) I .Subtraction Borrow-------------(?????)
        	[C] (...) I. Carry Left Shift---------------(?????)
        	[C] (...) I. Carry Right Shift--------------(?????)
        }

        floating point { OK

            [A] (...) FP. Addition----------------------(?????)
            [A] (...) FP. Subtraction-------------------(?????)
            [A] (...) FP. Multiplication----------------(?????)
            [A] (...) FP. Division----------------------(?????)
            [A] (...) FP. Multiply Acc------------------(?????)
            [A] (...) FP. Nth Root----------------------(?????)

            [B] (...) Imm. FP. Addition-----------------(?????)
            [B] (...) Imm. FP. Subtraction--------------(?????)
            [B] (...) Imm. FP. Multiplication-----------(?????)
            [B] (...) Imm. FP. Division-----------------(?????)
            [B] (...) Imm. FP. Multiply Acc-------------(?????)
        }
    }

    logic { OK

        [A] (...) Left Rotate-----------------------(?????)
        [A] (...) Right Rotate----------------------(?????)
        [A] (...) Bit Swap--------------------------(?????)
        [A] (...) Bitwise AND-----------------------(?????)
        [A] (...) Bitwise NAND----------------------(?????)
        [A] (...) Bitwise OR------------------------(?????)
        [A] (...) Bitwise NOR-----------------------(?????)
        [A] (...) Bitwise XOR-----------------------(?????)
        [A] (...) Bitwise XNOR----------------------(?????)
        [A] (...) Carry-less Multiplication---------(?????)

        [C] (...) I. Left Rotate--------------------(?????)
        [C] (...) I. Right Rotate-------------------(?????)
        [C] (...) I. Bit Swap-----------------------(?????)
        [B] (...) I. Bitwise AND--------------------(?????)
        [B] (...) I. Bitwise NAND-------------------(?????)
        [B] (...) I. Bitwise OR---------------------(?????)
        [B] (...) I. Bitwise NOR--------------------(?????)
        [B] (...) I. Bitwise XOR--------------------(?????)
        [B] (...) I. Bitwise XNOR-------------------(?????)
        [B] (...) I. Carryless Multiplication-------(?????)
    }

    miscellaneous { OK

        [D] (...) Get Bit Field---------------------(?????)
        [D] (...) Set Bit Field---------------------(?????)

        [A] (...) Count Ones------------------------(?????)
    	[A] (...) Count Leading Ones----------------(?????)
    	[A] (...) Count Trailing Ones---------------(?????)
    	[A] (...) Count Zeros-----------------------(?????)
    	[A] (...) Count Leading Zeros---------------(?????)
    	[A] (...) Count Trailing Zeros--------------(?????)
    }

    TODO: reduction instructions
    TODO: casts
}
______________________________________________________________________________________________________________________________________________________________________

Memory transfer {

    [E] (...) Memory Load-----------------------(?????)
    [E] (...) Memory Store----------------------(?????)
    [G] (...) Scaled Memory Load----------------(?????)
    [G] (...) Scaled Memory Store---------------(?????)
    [F] (...) I. Scaled Memory Load-------------(?????)
    [F] (...) I. Scaled Memory Store------------(?????)

    [E] (...) Vector Memory Load----------------(?????) .
    [E] (...) Vector Memory Store---------------(?????) .
    [G] (...) Vector Scaled Memory Load---------(?????) .
    [G] (...) Vector Scaled Memory Store--------(?????) .
    [F] (...) Vector I. Scaled Memory Load------(?????) .
    [F] (...) Vector I. Scaled Memory Store-----(?????) .

    [F] (...) Vector I. Stride Memory Load------(?????) .
    [F] (...) Vector I. Stride Memory Store-----(?????) .
    [G] (...) Vector Stride Memory Load---------(?????) .
    [G] (...) Vector Stride Memory Store--------(?????) .

    [F] (...) Load Linked-----------------------(?????)
    [F] (...) Store Conditional-----------------(?????)

    [H] (...) Block Load------------------------(?????)
    [H] (...) Block Store-----------------------(?????)

    TODO: conditional moves
    TODO: unconditional moves
}
______________________________________________________________________________________________________________________________________________________________________

Control transfer {

    ...
}
______________________________________________________________________________________________________________________________________________________________________

System {

    ...
}
______________________________________________________________________________________________________________________________________________________________________

REGISTERS {

    TODO: define ABI

    - 3 files in total:

        - 0 -> scalar file: 32 regs in total (int & fp shared)
        - 1 -> vector file: 32 regs in total (int & fp shared)
        - 2 -> special file: 32 regs in total (see below for details)

    file 0 {

        $00----(SGPR00 "scalar general purpose register 00")
        $01----(SGPR01 "scalar general purpose register 01")
        $02----(SGPR02 "scalar general purpose register 02")
        $03----(SGPR03 "scalar general purpose register 03")
        $04----(SGPR04 "scalar general purpose register 04")
        $05----(SGPR05 "scalar general purpose register 05")
        $06----(SGPR06 "scalar general purpose register 06")
        $07----(SGPR07 "scalar general purpose register 07")
        $08----(SGPR08 "scalar general purpose register 08")
        $09----(SGPR09 "scalar general purpose register 09")
        $10----(SGPR10 "scalar general purpose register 10")
        $11----(SGPR11 "scalar general purpose register 11")
        $12----(SGPR12 "scalar general purpose register 12")
        $13----(SGPR13 "scalar general purpose register 13")
        $14----(SGPR14 "scalar general purpose register 14")
        $15----(SGPR15 "scalar general purpose register 15")
        $16----(SGPR16 "scalar general purpose register 16")
        $17----(SGPR17 "scalar general purpose register 17")
        $18----(SGPR18 "scalar general purpose register 18")
        $19----(SGPR19 "scalar general purpose register 19")
        $20----(SGPR20 "scalar general purpose register 20")
        $21----(SGPR21 "scalar general purpose register 21")
        $22----(SGPR22 "scalar general purpose register 22")
        $23----(SGPR23 "scalar general purpose register 23")
        $24----(SGPR24 "scalar general purpose register 24")
        $25----(SGPR25 "scalar general purpose register 25")
        $26----(SGPR26 "scalar general purpose register 26")
        $27----(SGPR27 "scalar general purpose register 27")
        $28----(SGPR28 "scalar general purpose register 28")
        $29----(SGPR29 "scalar general purpose register 29")
        $30----(SGPR30 "scalar general purpose register 30")
        $31----(SGPR31 "scalar general purpose register 31")
    }

    file 1 {

        &00----(VGPR00 "vector general purpose register 00")
        &01----(VGPR01 "vector general purpose register 01")
        &02----(VGPR02 "vector general purpose register 02")
        &03----(VGPR03 "vector general purpose register 03")
        &04----(VGPR04 "vector general purpose register 04")
        &05----(VGPR05 "vector general purpose register 05")
        &06----(VGPR06 "vector general purpose register 06")
        &07----(VGPR07 "vector general purpose register 07")
        &08----(VGPR08 "vector general purpose register 08")
        &09----(VGPR09 "vector general purpose register 09")
        &10----(VGPR10 "vector general purpose register 10")
        &11----(VGPR11 "vector general purpose register 11")
        &12----(VGPR12 "vector general purpose register 12")
        &13----(VGPR13 "vector general purpose register 13")
        &14----(VGPR14 "vector general purpose register 14")
        &15----(VGPR15 "vector general purpose register 15")
        &16----(VGPR16 "vector general purpose register 16")
        &17----(VGPR17 "vector general purpose register 17")
        &18----(VGPR18 "vector general purpose register 18")
        &19----(VGPR19 "vector general purpose register 19")
        &20----(VGPR20 "vector general purpose register 20")
        &21----(VGPR21 "vector general purpose register 21")
        &22----(VGPR22 "vector general purpose register 22")
        &23----(VGPR23 "vector general purpose register 23")
        &24----(VGPR24 "vector general purpose register 24")
        &25----(VGPR25 "vector general purpose register 25")
        &26----(VGPR26 "vector general purpose register 26")
        &27----(VGPR27 "vector general purpose register 27")
        &28----(VGPR28 "vector general purpose register 28")
        &29----(VGPR29 "vector general purpose register 29")
        &30----(VGPR30 "vector general purpose register 30")
        &31----(VGPR31 "vector general purpose register 31")
    }

    file 2 {

        %00----(SGPR32 "scalar general purpose register 32")
        %01----(SGPR33 "scalar general purpose register 33")
        %02----(SGPR34 "scalar general purpose register 34")
        %03----(SGPR35 "scalar general purpose register 35")
        %04----(SGPR36 "scalar general purpose register 36")
        %05----(SGPR37 "scalar general purpose register 37")
        %06----(SGPR38 "scalar general purpose register 38")
        %07----(SGPR39 "scalar general purpose register 39")

        %08----(BPR0 "breakpoint register 0")
        %09----(BPR1 "breakpoint register 1")
        %10----(BPR2 "breakpoint register 2")
        %11----(BPR3 "breakpoint register 3")
        %12----(BPR4 "breakpoint register 4")
        %13----(BPR5 "breakpoint register 5")
        %14----(BPR6 "breakpoint register 6")
        %15----(BPR7 "breakpoint register 7")

        %16----(BPM "breakpoint modes")
        %17----(VMSK "vector mask")

        %18----(PC "program counter")
        %19----(UPC "user program counter")
        %20----(UCSR "user control & status register")
        %21----(VFLG "vector flags")

      * %22----(CSR "control & status register")
      * %23----(SPC "supervisor program counter")
      * %24----(SCSR "supervisor control & status register")
      * %25----(K0 "kernel temporary 0")
      * %26----(K1 "kernel temporary 1")
      * %27----(ETP "event table pointer")
      * %28----(PTP "page table pointer")
      * %29----(PID "process identifier")
        %30----
        %31----
    }

    CSR bit layout {

        - COVR (1) flag
        - CUND (1) flag
        - OVFL (1) flag
        - UNFL (1) flag
        - DIV0 (1) flag
        - ???? (1) flag
        - ???? (1) flag
        - ???? (1) flag

        - LEN (2) (data type length)
        - IMOD (3) (instruction mode, see table below)
        - RMD (2) (rounding modes)
        - TD (8) (transaction nesting depth counter)

        - SUPERVISOR MODE                   (1)
		- CONSISTENCY MODE                  (1)
		- BOOT MODE                         (1)
		- ENABLE PAGING                     (1)
		- ENABLE AUTO EXCEPTIONS            (1)
		- ENABLE USER INTERRUPTS            (1)
		- ENABLE SUPERVISOR INTERRUPTS      (1)
		- EVENT TRIGGERED                   (1)
		- HALT EXECUTION                    (1)
    }

    IMOD(3):

        000 -> scalar int
        001 -> vector-vector int
        010 -> vector-scalar int
        011 -> reduction int
        100 -> scalar fp
        101 -> vector-vector fp
        110 -> vector-scalar fp
        111 -> reduction fp
}
______________________________________________________________________________________________________________________________________________________________________
