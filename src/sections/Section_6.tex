\section[Events]{\LARGE\underline{Events}}

    \vspace{10pt}

    This section is dedicated to the specification of exceptions, faults and interrupts which are needed to implement the EXC, FLT, IOINT, IPCINT, DBGR and TM modules. FabRISC uses the term \textit{event} to indicate the generic categorization of these kinds of situations. Events can be used to communicate with other harts, processes, IO devices, signal system faults or simply trigger software exceptions. Events are sub divided into two main categories: Synchronous and Asynchronous.

    \subsection{Synchronous}

        \vspace{10pt}

        Synchronous events are internally generated and are considered deterministic, that is, if they happen, they will always happen in the same location of the executing program and, because of this, the handling must done in program order. This category is further sub divided in two.

        \begin{itemize}

            \item \textit{\textbf{Exceptions}: These events are user handled, non promoting and with a global priority level of 0 through 2. They are generated by the executing instructions and each process can have it's own private handler with the help of a dedicated pointer register. From a higher level, the handling of exceptions looks like an automatic function call to the specified handler address.}

            \item \textit{\textbf{Faults}: These events are supervisor handled, promoting and with a global priority level of 4. They are generated by the executing instructions and each process will have the same handler dictated by the supervisor. From a high level, the handling of faults looks like an automatic function call performed by the supervisor to a location that is always the same.}

        \end{itemize}

    \par\noindent\rule{\textwidth}{0.4pt}
    \textit{Exceptions and faults are used to identify software related problems and edge cases such as overflows, divisions by zero, memory accesses to protected sections and more. I believe that exceptions can be valuable and useful for handling special cases quickly and preemptively without having to perform time consuming checks over and over. Examples of this can be seamless array boundary checks via the use of debugging registers (see section 8 for more information) that trigger the appropriate exception. Arithmetic edge cases can be similarly treated via the use of said special registers or by operating the processor in a ``safe state'', which will trigger the appropriate exception every time something went wrong with the executing software. Faults are similar to exceptions but for more delicate problems such as page faults, illegal or malformed instructions and accesses to protected memory areas. All in all, i believe that one cannot really design a hardware system where these kinds of problems never occur, which is why i put emphasis on being able to gracefully recover when such cases happen.}
    \par\noindent\rule{\textwidth}{0.4pt}

    \subsection{Asynchronous}

        \vspace{10pt}

        Asynchronous events are externally generated and are not considered deterministic, that is, they can happen at any time regardless of what the CPU is doing. Asynchronous events can be masked but only by the supervisor and should be handled as soon as possible in order to keep latency low. This category is further sub divided in two:

        \begin{itemize}

            \item \textit{\textbf{IO interrupts}: These events are supervisor handled, promoting with a global priority level of 5. They are generated by external IO devices and can have an internal priority level to decide which one to handle when multiple are triggered at the same time. From a high level, the handling of IO interrupts, can be considered as a context switch to the desired process that will handle the device request, which can be achieved in a similar fashion to faults.}

            \item \textit{\textbf{IPC interrupts}: These events are supervisor handled, promoting with a global priority level of 3. They are generated by other harts in the system in order to communicate with each other (inter-process communication) and can have an internal priority level to decide which one to handle when multiple are triggered at the same time. From a high level, the handling of IPC interrupts, can be considered as a context switch to the desired process that will handle the IPC request, which can be achieved in a similar fashion to faults and IO interrupts.}

        \end{itemize}

    \par\noindent\rule{\textwidth}{0.4pt}
    \textit{I think that interrupts are a great tool that allow the IO devices themselves to start the communication, as opposed to the time consuming polling. This option is especially useful when low latency is required and can be used in conjunction with the regular low speed memory mapped IO transfers or the faster DMA. For devices that do not need any kind of bandwidth or responsiveness, polling can still be a valid choice without utilizing any extra resources. A shadow register file can potentially be utilized to reduce the latency to a minimum, however, it must behave transparently to the programmer.}
    \par\noindent\rule{\textwidth}{0.4pt}

    \subsection{Event requirements}

        In order to be able to handle any kind of event, the hardware must provide the CAUSE register which is used to store the unique identifier of the triggered event. If multiple event modules are implemented, multiple instances of the same requirements are, obviously, needed just once. A list containing all the possible events is provided at the bottom of this section.

        \begin{itemize}

            \item \textit{\textbf{EXC module}: this module adds exceptions to the architecture. The hardware must implement the EB0, EB1, EB2 and UEHP registers that are used as buffers when an exception is triggered.}

            \item \textit{\textbf{TM module}: this module adds aborts code to the architecture. The hardware must implement the EB0, EB1, EB2 and UEHP registers that are used as buffers when an exception is triggered. Other requirements for this module can be found in section 4.}

            \item \textit{\textbf{DBGR module}: this module adds breakpoints to the architecture. The hardware must implement the EB0, EB1, EB2 and UEHP registers that are used as buffers when an exception is triggered. Other requirements for this module can be found in section 8.}

            \item \textit{\textbf{FLT module}: this module adds faults to the architecture. The hardware must implement the SEB0, SEB1, SEB2 and SEHP registers that are used as buffers when a fault is triggered. Faults are a promoting event and relies on the presence of the supervisor.}

            \item \textit{\textbf{IOINT module}: this module adds IO interrupts to the architecture. The hardware must implement the SEB0, SEB1, SEB2 and SEHP registers that are used as buffers when an IO interrupt is triggered. IO interrupts are a promoting event and relies on the presence of the supervisor.}

            \item \textit{\textbf{IPCINT module}: this module adds IPC interrupts to the architecture. The hardware must implement the SEB0, SEB1, SEB2 and SEHP registers that are used as buffers when an IPC interrupt is triggered. IPC interrupts are a promoting event and relies on the presence of the supervisor.}

        \end{itemize}

        If the supervisor is not decided to be implemented, the FLT, IOINT and IPCINT modules can still be implemented without the supervisor. Some events, specifically the ILLI, MALI, MISI and INCI are mandatory and must always be implemented. FabRISC categorizes them as privileged synchronous events (faults), but if the supervisor isn't implemented, then the handlers can be programmed in a constant fixed location. This is a small special case in the specification in order to accommodate very simple machines such as small micro controllers which don't need or require any privileged ISA capability because they, usually, don't run an OS.

    \subsection{Event handling}

        \vspace{10pt}

        Handling events involves a \textit{``launching''} phase and a \textit{``returning''} phase. The steps of each phase must be performed by the trapped hart in a single cycle in order to avoid potential corruption of its internal state. The launching phase is composed of the following parallel steps:

        \begin{enumerate}

            \item \textit{write the event identifier into the cause register (CAUSE).}

            \item \textit{save the value of the program counter (PC) and status register (CSR) into the appropriate buffer registers depending on the privilege level of the event:}

                \begin{itemize}

                    \item \textit{for non-promoting events, simply copy the PC into the exception buffer 0 (EB0), the CSR into the exception buffer 1 (EB1) and the old CAUSE register into the exception buffer 2 (EB2).}

                    \item \textit{for promoting events, simply copy the PC, into the supervisor event buffer 0 (SEB0), the CSR into the supervisor event buffer 1 (SEB1) and the old CAUSE register into the supervisor event buffer 2 (SEB2).}

                \end{itemize}

            \item \textit{mask any other interrupt if the triggered event is promoting, otherwise skip this step. The masking can be accomplished by simply setting the IPCM and IOIM bits in the CSR to one.}

            \item \textit{set the TRAP bit of the CSR to one in order to signify that the hart is handling an event.}

            \item \textit{switch to supervisor mode if the triggered event is promoting by setting the SUPB bit in the CSR, otherwise skip this step.}

            \item \textit{jump to the handler location with the use of the appropriate pointer register. Depending of the privilege level of the event this step will involve:}

                \begin{itemize}

                    \item \textit{for non-promoting events, a simple copy of the value of the user event handler pointer (UEHP) into the program counter suffices. From there a case statement can be used in combination with the CAUSE register to determine which event was generated.}

                    \item \textit{for promoting events, a simple copy of the value of the supervisor event handler pointer (SEHP) into the program counter suffices. From there a case statement can be used in combination with the CAUSE register to determine which event was generated.}

                \end{itemize}

        \end{enumerate}

        After the execution of the desired handler code, the last instruction will trigger the returning phase. During that phase, it is sufficient to restore the value of the program counter, the status register and, if the event was promoting, the CAUSE register by storing into them the values of the appropriate buffer registers previously written. It is important to note that the processor must always trap preemptively, that is, before the trapping instruction writes the result and, after the return phase, the processor must replay the instruction that caused the event.

        \vspace{10pt}

        Global priority, introduced in the previous subsections, is used to give a further discriminant in case different types of events are triggered in the same clock cycle. Events with global priority level of 5 will be considered first, all the way to global priority level 0. Local priority simply specifies the order in which events of the same type must be handled and only concerns asynchronous events. Local priority can be dynamically changed by the supervisor with the help of the IO controller, which should be responsible for scheduling the actual interrupt to be sent to the target hart. It is important to note that it is forbidden to have more than one IO or IPC interrupt with the same local priority. This is because there shouldn't be any ambiguity on the scheduling order. Synchronous events do not have local priority because exceptions with the same global priority should be scheduled in program order.

        \vspace{10pt}

        Performance counters, if present, must be freezed if the triggered event is promoting. If the supervisor needs the performance monitoring counters, it must save them first before unfreezing them. The supervisor must restore the proper values of the counters before actually scheduling a user process for execution. This ensures the retention of values across context switches and event handling.

    \par\noindent\rule{\textwidth}{0.4pt}
    \textit{Handling events should be quite a straight forward process. The launching phase explains all the needed steps to successfully branch to the target location. Once the handler is executed the ERET instruction can be executed to bring back the old state. This mechanism can be used to schedule another process entirely, by setting all the registers to the desired values and executing an ERET instruction which causes the PC and CSR to be written with the values held in the supervisor event buffers. When an event of any kind is triggered, it's necessary to flush or invalidate any in-flight instruction including the very last stage (write-back / commit). This is because it's possible to perform (absolute) branches by simply writing to the program counter directly with a standard move instruction, which means that the control flow can erroneously be steered back causing the execution of wrong instructions if the last stage is left unaltered.}
    \par\noindent\rule{\textwidth}{0.4pt}

    \vspace{10pt}
    \input{./Tables/Supervisor_event_table.tex}
    \vspace{10pt}
    \input{./Tables/User_event_table.tex}
    \vspace{10pt}