\section[Events]{\LARGE\underline{Events}}

    \vspace{10pt}

    This section is dedicated to the specification of exceptions, faults and interrupts which are needed to implement the EXC, FLT, IOINT, IPCINT, DBGR and TM modules. FabRISC uses the term \textit{event} to indicate the generic categorization of these kinds of situations. Events can be used to communicate with other harts, processes, IO devices, signal system faults or simply trigger software exceptions. Events are sub divided into two main categories: Synchronous and Asynchronous.

    \subsection{Synchronous events}

        \vspace{10pt}

        Synchronous events are internally generated and are considered deterministic, that is, if they happen, they will always happen in the same location of the executing program and, because of this, the handling must done in program order unless noted otherwise. This category is further sub divided in two:

        \begin{itemize}

            \item \textit{\textbf{Exceptions}: these events are user handled, non promoting and with a global priority level of 0 through 2. They are generated by the executing instructions and each process can have it's own private handler with the help of a dedicated pointer register. From a higher level, the handling of exceptions looks like an automatic function call to the specified handler address all within the address space of the process in question.}

            \item \textit{\textbf{Faults}: these events are supervisor handled, promoting and with a global priority level of 4. They are generated by the executing instructions and each process will have the same handler dictated by the supervisor. From a high level, the handling of faults looks like an automatic function call performed by the supervisor to a location that is always the same and part of the OS code.}

        \end{itemize}

    \par\noindent\rule{\textwidth}{0.4pt}
    \textit{Exceptions and faults are used to identify software related problems and edge cases such as overflows, divisions by zero, memory accesses to protected sections and more. I believe that exceptions can be valuable and useful for handling special cases quickly and preemptively without having to perform time consuming checks over and over. Examples of this can be seamless array boundary checks via the use of debugging registers (see section 8 for more information) that trigger the appropriate exception. Arithmetic edge cases can be similarly treated via the use of said special registers or by operating the processor in a ``safe state'', which will trigger the appropriate exception every time something went wrong with the executing software. Faults are similar to exceptions but for more delicate problems such as page faults, illegal or malformed instructions and accesses to protected memory areas. All in all, i believe that one cannot really design a hardware system where these kinds of problems never occur, which is why i put emphasis on being able to gracefully recover when such cases happen.}
    \par\noindent\rule{\textwidth}{0.4pt}

    \subsection{Asynchronous events}

        \vspace{10pt}

        Asynchronous events are externally generated and are not considered deterministic, that is, they can happen at any time regardless of what the CPU is doing. Asynchronous events can be masked but only by the supervisor and should be handled as soon as possible in order to keep latency low. This category is further sub divided in two:

        \begin{itemize}

            \item \textit{\textbf{IO interrupts}: these events are supervisor handled, promoting with a global priority level of 5. They are generated by external IO devices and can have a dynamic internal priority level to decide which one to handle when multiple are triggered at the same time. From a high level, the handling of IO interrupts, can be considered as a context switch to the desired process that will handle the device request, which can be achieved in a similar fashion to faults.}

            \item \textit{\textbf{IPC interrupts}: These events are supervisor handled, promoting with a global priority level of 3. They are generated by other harts in the system in order to communicate with each other (inter-process communication) and can have a dynamic internal priority level to decide which one to handle when multiple are triggered at the same time. From a high level, the handling of IPC interrupts, can be considered as a context switch to the desired process that will handle the IPC request, which can be achieved in a similar fashion to faults and IO interrupts.}

        \end{itemize}

    \par\noindent\rule{\textwidth}{0.4pt}
    \textit{I think that interrupts are a great tool that allow the IO devices themselves to start the communication, as opposed to the time consuming polling. This option is especially useful when low latency is required and can be used in conjunction with the regular low speed memory mapped IO transfers or the faster DMA. For devices that do not need any kind of bandwidth or responsiveness, polling can still be a valid choice without utilizing any extra resources. A shadow register file can potentially be utilized to reduce the latency to a minimum, however, it must behave transparently to the programmer. IPC interrupts are intended for communication between different processes or threads. Conceptually, they work in a similar fashion to IO interrupts with the only difference being that IPC interrupts are generated by other processes or threads.}
    \par\noindent\rule{\textwidth}{0.4pt}

    \subsection{Event modules requirements}

        In order to be able to handle any kind of event, the hardware must provide the CAUSE register which is used to store the unique identifier of the triggered event. If multiple event modules are implemented, multiple instances of the same requirements are, obviously, needed just once. A list containing all the possible events is provided at the bottom of this section.

        \begin{itemize}

            \item \textit{\textbf{EXC module}: this module adds exceptions to the architecture. The hardware must implement the EB0, EB1, EB2 and UEHP registers that are used as buffers when an exception is triggered.}

            \item \textit{\textbf{TM module}: this module adds aborts code to the architecture. The hardware must implement the EB0, EB1, EB2 and UEHP registers that are used as buffers when an exception is triggered. Other requirements for this module can be found in section 4.}

            \item \textit{\textbf{DBGR module}: this module adds breakpoints to the architecture. The hardware must implement the EB0, EB1, EB2 and UEHP registers that are used as buffers when an exception is triggered. Other requirements for this module can be found in section 8.}

            \item \textit{\textbf{FLT module}: this module adds faults to the architecture. The hardware must implement the SEB0, SEB1, SEB2 and SEHP registers that are used as buffers when a fault is triggered. Faults are a promoting event and relies on the presence of the supervisor.}

            \item \textit{\textbf{IOINT module}: this module adds IO interrupts to the architecture. The hardware must implement the SEB0, SEB1, SEB2 and SEHP registers that are used as buffers when an IO interrupt is triggered. IO interrupts are a promoting event and relies on the presence of the supervisor.}

            \item \textit{\textbf{IPCINT module}: this module adds IPC interrupts to the architecture. The hardware must implement the SEB0, SEB1, SEB2 and SEHP registers that are used as buffers when an IPC interrupt is triggered. IPC interrupts are a promoting event and relies on the presence of the supervisor.}

        \end{itemize}

        If the supervisor is not decided to be implemented, the FLT, IOINT and IPCINT modules can still be implemented without it by hard-coding the handlers in memory locations that are always the same. This alleviates the requirements for simpler machines such as micro controllers which don't need or require any privileged ISA capability because they, usually, do not run any operative system. Some events of the FLT module are mandatory, specifically the ILLI, MALI, MISI and INCI events are mandatory and must always be implemented.

    \subsection{Event handling}

        \vspace{10pt}

        Handling events involves a \textit{``launching''} phase and a \textit{``returning''} phase. The steps of each phase must be performed by the trapped hart in a single cycle in order to avoid potential corruption of its internal state. The launching phase is composed of the following parallel steps:

        \begin{enumerate}

            \item \textit{save the value of the program counter (PC) and status register (CSR) into the appropriate buffer registers depending on the privilege level of the event:}

                \begin{itemize}

                    \item \textit{for non-promoting events, simply copy the PC into the exception buffer 0 (EB0), the CSR into the exception buffer 1 (EB1) and the CAUSE register into the exception buffer 2 (EB2).}

                    \item \textit{for promoting events, simply copy the PC, into the supervisor event buffer 0 (SEB0), the CSR into the supervisor event buffer 1 (SEB1) and the CAUSE register into the supervisor event buffer 2 (SEB2).}

                \end{itemize}

            \item \textit{write the event identifier into the cause register (CAUSE).}

            \item \textit{disable the handling of any further event depending on the type:}

                \begin{itemize}

                    \item \textit{if the event is an exception, disable the auto exception mode by setting the AEXC and the DBGF bits in the CSR to zero and one respectively in order to suppress any further exception event.}

                    \item \textit{if the event is an interrupt, mask any other potential incoming interrupt by setting the IPCM, IOIM, DBGF and CNTF bits in the CSR to one for all of them in order to suppress any other unwanted event, as well as freezing any potential active performance counter.}

                \end{itemize}

            \item \textit{set the TRAP bit of the CSR to one in order to signify that the hart is handling an event.}

            \item \textit{switch to supervisor mode if the triggered event is promoting by setting the SUPB bit in the CSR, otherwise skip this step.}

            \item \textit{jump to the handler location with the use of the appropriate pointer register. Depending of the privilege level of the event this step will involve:}

                \begin{itemize}

                    \item \textit{for non-promoting events, a simple copy of the value of the user event handler pointer (UEHP) into the program counter suffices. From there a case statement can be used in combination with the CAUSE register to determine which event was generated.}

                    \item \textit{for promoting events, a simple copy of the value of the supervisor event handler pointer (SEHP) into the program counter suffices. From there a case statement can be used in combination with the CAUSE register to determine which event was generated.}

                \end{itemize}

        \end{enumerate}

        Step number 3 is critical in avoid potential corruption of the state while the handler is saving important registers to memory. In order to allow nesting of exceptions, once the critical user registers (exception buffers) have been saved to the call stack in main memory, simply re-enabling the AEXC and disabling the DBGF bits will allow any pending exception to trap the hart again re-triggering the handling procedure. Exceptions triggered during this period of ``blindness'' might be queued to avoid loss of information. A similar picture can be painted for interrupts and the queuing might be performed by the IO controller or in the core internally as well. The supervisor is allowed to interrupt the user at any time without corrupting the user state since the critical registers are saved into the supervisor event buffers. Nesting faults can be also accomplished in the same way as exceptions, however it's possible to come across the ``double fault'' edge case which is going to be explained in more detail shortly. After the successful handling of an event, the returning phase can be performed by executing the ERET instruction (see section 9 for more information). The returning phase will move the exception buffers or supervisor event buffers back into their corresponding locations according to the promotion type of the event: an ERET from a non promoting event will move the exception buffers back, while an ERET from a promoting event will move the supervisor event buffers back. It is worth noting that for exceptions generated by arithmetic instructions, such as overflows or division by zero, the hart must replay the offending instruction after the handling of the event with now, hopefully, correct parameters.

        \vspace{10pt}

        Global priority, introduced in the previous subsections, is used to give a further discriminant in case different types of events are triggered in the same clock cycle. Events with global priority level of 5 will be considered first, all the way to global priority level 0. Local priority simply specifies the order in which events of the same type must be handled and only concerns asynchronous events. Local priority can be dynamically changed by the supervisor with the help of the IO controller, which should be responsible for scheduling the actual interrupt to be sent to the target hart. It is important to note that it is forbidden to have more than one IO or IPC interrupt with the same local priority. This is because there shouldn't be any ambiguity on the scheduling order. Synchronous events from the EXC and TM modules do not have local priority because those exceptions are generated from the instructions themselves and should, therefore, be handled in program order. The DBGR module, however, allows the triggering of multiple events needing an internal priority between the said events.

        \vspace{10pt}

        Performance counters and debugging registers, if present, must be freezed if the triggered event is promoting which is accomplished via the DBGF and the CNTF bits. If the supervisor needs said resources, it must save them first before utilizing them. The supervisor must restore the proper values back before actually scheduling a user process for execution. This ensures the retention of values across context switches and event handling.

    \subsection{Double fault}

        During the handling of an exception, if another fault event is triggered before having saved the supervisor buffer registers to memory the state might become corrupt because those registers will be overwritten, thus, corrupting the previous values. This situation can happen if the second event is either: ILLI, MALI, MISI, PGFT or INCI fault. Those faults might afflict the supervisor code responsible of scheduling the handlers if it contains an: illegal, malformed, misaligned, incompatible instruction or a page fault. If said problematic instruction is executed before saving the supervisor event buffers to memory, corruption of state is unavoidable. If such situation is detected, the hart must be immediately halted and the DBF bit in the CSR must be set to one, signifying the presence of a double fault. Avoiding a double fault caused by the PGFT event can be done by always having that portion of code in memory.

    \par\noindent\rule{\textwidth}{0.4pt}
    \textit{Handling events should be quite a straight forward process. The launching phase explains all the needed steps to successfully branch to the target location. Once the handler is executed the ERET instruction can be executed to bring back the old state. This mechanism can be used to schedule another process entirely, by setting all the registers to the desired values and executing an ERET instruction which causes the PC and CSR to be written with the values held in the supervisor event buffers. When an event of any kind is triggered, it's necessary to flush or invalidate any in-flight instruction including the very last stage (write-back / commit). This is because it's possible to perform (absolute) branches by simply writing to the program counter directly with a standard move instruction, which means that the control flow can erroneously be steered back causing the execution of wrong instructions if the last stage is left unaltered. Events are not perfect mechanisms and can result in the awful double fault situation. Luckily this situation can only arise if the supervisor code responsible for launching the handlers themselves contains erroneous instructions. In order to get rid of the double fault, that particular supervisor code must never cause the mentioned faults and must always be loaded into memory to avoid page faults.}
    \par\noindent\rule{\textwidth}{0.4pt}

    \vspace{10pt}
    \input{./Tables/User_event_table.tex}
    \clearpage
    \input{./Tables/Supervisor_event_table.tex}
    \vspace{10pt}