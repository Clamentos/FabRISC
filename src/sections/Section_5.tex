\section[Input Output]{\LARGE\underline{Input Output}}

    \vspace{10pt}

    This section is dedicated to the specification that FabRISC uses for communicating with external devices as well as other cores and hardware threads if present. The architecture defines IO mappings, potential DMA behavior and, in the next section, OS support and inter-process communication schemes are discussed.

    \subsection{Memory mapped IO}

        \vspace{10pt}

        FabRISC reserves a portion of the high memory address space to \textit{memory mapped IO}. This region, of the size of $2^{16}$ bytes, is not cached nor paged and byte addressable in little-endian order. If a hart wants to transfer data to an IO device it can simply execute a memory operation to this section without further complications. The IO device must map all of its internal registers and state to this region and multiple channels or buses can potentially be employed to reduce the latency in case another transfers are already taking place as well as increasing the bandwidth. It is important to note that this region, is not paged in the traditional sense, that is, the virtual to physical mapping will always be the same, however it must still have page table entries for protection bits. The ISA splits this MMIO address space in two segments:

        \begin{itemize}

            \item \textit{\textbf{CPU segment}: this portion, starting from address zero of the MMIO space, is composed of 128 bytes and should be used to hold CPU information, such as implemented ISA extensions, cache sizes as well as other CPU capabilities and characteristics.}

            \item \textit{\textbf{IO segment}: this portion, starting from address 128 of the MMIO space, is composed of 65408 bytes and should be used to communicate with external devices via MMIO.}

        \end{itemize}

        \vspace{10pt}
        \input{./Tables/CPU_segment_table.tex}
        \vspace{10pt}

    \par\noindent\rule{\textwidth}{0.4pt}
    \textit{I decided to go with memory mapped IO because of its flexibility and simplicity compared to port based solutions. The IO region can be considered plain memory by the processor internally, which allows for advanced and fancy operations that use locks, barriers, fences and transactions to be done by multiple threads to the same device. I don't recommend caching or paging this region because it can yield potential inconsistencies and unnecessary complexities. This region still needs page table entries because of the protection bits, however, i suggest leaving the mappings of virtual to physical the same all the time for simplicity.}
    \par\noindent\rule{\textwidth}{0.4pt}

    \subsection{Direct memory access}

        \vspace{10pt}

        FabRISC provides the ability for IO devices to access the main system memory directly via DMA without passing through the processor. A dedicated centralized controller can be utilized to achieve this, but the hardware designer is free to choose another alternative if considered appropriate and, if this method of communication is chosen to be used, cache coherence must be ensured between the processor and the IO devices too. Some possible options can be, as discussed earlier:

        \begin{itemize}

            \item \textit{\textbf{Non cacheable memory region}: with this configuration coherence isn't a problem because no caching is performed by the CPU and the IO device in question. The system, however, needs to be able to dynamically declare which portion of memory is cacheable and which isn't which can lead to unnecessary complexities.}

            \item \textit{\textbf{Software IO coherence}: with this configuration the CPU and the device are required to flush or invalidate the cache explicitly with no extra hardware complexity, however, this option requires the exposure of the underlying organization to the programmer.}

            \item \textit{\textbf{Hardware IO coherence}: with this configuration, both the CPU and the IO device, will monitor each other's accesses via a common bus or a directory and proper actions are automatically taken according to a coherence protocol which can be the already existent one in the processor.}

        \end{itemize}

        The DMA protocol or scheme implemented by the hardware designer must also take consistency into account since memory operations to different addresses are allowed to be done out-of-order. This means that fencing instructions must retain their effect from the point of view of the hart and IO devices, which must provide similar fencing features as well.

    \par\noindent\rule{\textwidth}{0.4pt}
    \textit{For more bandwidth demanding devices, DMA can be used to transfer data at very high speeds in the order of several Gb/s without interfering with the CPU. This scheme however, is more complex than plain MMIO because of the special arbiter that handles and grants the requests. IO coherence, as well as its consistency, is actually the main reason of this subsection as a remainder that it needs to be considered during the development of the underlying microarchitecture, including the devices themselves via the use of atomic and fencing operations.}
    \par\noindent\rule{\textwidth}{0.4pt}