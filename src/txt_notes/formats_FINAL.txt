[A]   |OPCODE(07)|MOD(05)|RA(05)|RB(05) |RC(05) |RD(05)| 			r,r,r,r
[B]   |OPCODE(12)|MOD(04)|RA(05)|RB(05) |RC(05) | 					r,r,r
[C]   |OPCODE(16)|MOD(06)|RA(05)|RB(05) | 							r,r

[D]   |OPCODE(07)|MOD(03)|RA(05)|RB(05) |RC(05) |IMM(07)| 			r,r,r,i
[D.l] |OPCODE(07)|MOD(05)|RA(05)|RB(05) |RC(05) |IMM(21)| 			r,r,r,i

[E]   |OPCODE(07)|MOD(05)|RA(05)|RB(05) |IMM(10)| 					r,r,i
[E.l] |OPCODE(07)|MOD(05)|RA(05)|RB(05) |IMM(26)| 					r,r,i

[F]   |OPCODE(07)|MOD(04)|RA(05)|IMM(16)| 							r,i
[F.l] |OPCODE(07)|MOD(04)|RA(05)|IMM(32)| 							r,i

[G]   |OPCODE(07)|MOD(03)|RD/RS1(03)|RS2(03)| 						r,r
[H]   |OPCODE(11)|RS(05) |      									r

[I]   |OPCODE(07)|RA(03) |IMM(06)| 									r,i
[J]   |OPCODE(07)|IMM(09)| 											i

[K]   |OPCODE(16)| 													-
______________________________________________________________________________________________________________________________________________________________________

0000001 xxxxxxxxx -> 1111011 xxxxxxxxx 		(max: 123) (current: 112) [A] [D] [D.l] [E] [E.l] [F] [F.l] [G] [I] [J]
1111100 0000xxxxx -> 1111100 1111xxxxx 		(max:  16) (current:   5) [H]
1111101 00000xxxx -> 1111110 11111xxxx 		(max:  64) (current:  35) [B]
1111111 000000000 -> 1111111 001111111 		(max: 128) (current:  62) [C] [K]

384 combinations left
______________________________________________________________________________________________________________________________________________________________________

[A] format {
	
	[A]   |OPCODE(07)|MOD(05)|RA(05)|RB(05)|RC(05)|RD(05)|    length: 4B

    type: R,R,R,R

	scalar memory & strided vector:

        MOD(05): "ttmuu"

        {

            reg[RA] <--> mem[reg[RB] + (reg[RC] * reg[RD])];
            reg[RB] = update(reg[RB]);
        }

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)
        ('uu' is update mode: 00 nothing, 01 post-inc, 10 post-dec, 11 pre-dec)

    vector load & store instructions:

        MOD(05): "oomuu"

        {

            reg[RA] <--> mem[reg[RB] + (reg[RC] * reg[RD])];
            reg[RB] = update(reg[RB]);
        }

        ('oo' are extra opcode bits)
        ('m' is mask: 0 unmasked, 1 masked)
        ('uu' is update mode: 00 nothing, 01 post-inc, 10 post-dec, 11 pre-dec)
}
______________________________________________________________________________________________________________________________________________________________________

[B] format {
	
	[B]   |OPCODE(12)|MOD(04)|RA(05)|RB(05)|RC(05)|    length: 4B

    type: R,R,R

	computational instructions:

        MOD(05): "ttmvv"

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)
        ('vv' is vector mode: 00 scalar, 01 vector-vector, 10 vector-scalar)

    vector gather & scatter instructions:

        MOD(05): "ttm--"

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)

    atomic CAS instructions:

        MOD(05): "ttmcc"

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)
        ('cc' is condition to perform: 00 EQ, 01 NE, 10 LT, 11 LE)
}
______________________________________________________________________________________________________________________________________________________________________

[C] format {
	
	[C]   |OPCODE(16)|MOD(06)|RA(05)|RB(05)|    length: 4B

    type: R,R

	computational instructions:
    
        MOD(06): "ttm--v"

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)
        ('v' is vector mode: 0 scalar, 1 vector)

    computational reduction instructions:

        MOD(06): "ttm--d":

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)
        ('d' is direction for non commutative operations)

    casts & conversion instructions:
    
        MOD(06): "ttm-tt"

        ('tt', 'tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)

    move & swap instructions:

        MOD(06): "ttmnnn"

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)
        ('nnn' is number of regs acted)

    compare mask setting instructions:
    
        MOD(06): "ttm-cc"

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)
        ('cc' is condition: 00 EQ, 01 NE, 10 LT, 11 LE)
}
______________________________________________________________________________________________________________________________________________________________________

[D] format {
	
	[D]   |OPCODE(07)|MOD(03)|RA(05)|RB(05)|RC(05)|IMM(07)|    length: 4B
	[D.l] |OPCODE(07)|MOD(05)|RA(05)|RB(05)|RC(05)|IMM(21)|    length: 6B

    type: R,R,R,I

	scalar memory & strided vector instructions:

        MOD(03): "ttm"
        MOD(05): "ttmuu"

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)
        ('uu' is update mode: 00 nothing, 01 post-inc, 10 post-dec, 11 pre-dec)

    vector load & store instructions:

        MOD(03): "oom"
        MOD(05): "oomuu"

        ('oo' are extra opcode bits)
        ('m' is mask: 0 unmasked, 1 masked)
        ('uu' is update mode: 00 nothing, 01 post-inc, 10 post-dec, 11 pre-dec)
}
______________________________________________________________________________________________________________________________________________________________________

[E] format {
	
	[E]   |OPCODE(07)|MOD(05)|RA(05)|RB(05)|IMM(10)|    length: 4B
	[E.l] |OPCODE(07)|MOD(05)|RA(05)|RB(05)|IMM(26)|    length: 6B

    type: R,R,I

	computational instructions:

        [E, E.l] MOD(05): "ttmvo"

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is mask: 0 unmasked, 1 masked)
        ('v' is vector mode: 0 scalar, 1 vector-scalar)
        ('o' is extra opcode bit)

	scalar memory & strided vector instructions:

        [E]   MOD(05): "ttmii"
        [E.l] MOD(05): "ttmuu"

        ('tt' is data type length: 8, 16, 32, 64)
        ('m' is maks: 0 unmasked, 1 masked)
        ('i' is extra immediate)
        ('uu' is update mode: 00 nothing, 01 post-inc, 10 post-dec, 11 pre-dec)

    vector load & store instructions:

        [E]   MOD(05): "omaii"
        [E.l] MOD(05): "omauu"

        ('o' is extra opcode bit)
        ('m' is mask: 0 unmasked, 1 masked)
        ('i' is extra immediate)
        ('uu' is update mode: 00 nothing, 01 post-inc, 10 post-dec, 11 pre-dec)

    conditional compare branches:

        [E]   MOD(05): "ttpii"
        [E.l] MOD(05): "ttpcc"

        ('tt' is data type length: 8, 16, 32, 64)
        ('cc' is condition: 00 EQ, 01 NE, 10 LT, 11 LE)
        ('p' is floating point mode)
        ('i' is extra immediate)

    indirect function calls & jumps:

    	[E]   MOD(05): "iiiii"
    	[E.l] MOD(05): "iiiii"

    	('i' extra immediate)
}
______________________________________________________________________________________________________________________________________________________________________

[F] format {
	
	[F]   |OPCODE(07)|MOD(04)|RA(05)|IMM(16)|    length: 4B
	[F.l] |OPCODE(07)|MOD(04)|RA(05)|IMM(32)|    length: 6B

    type: R,I

	block load & store instructions:
    
        MOD(04): "ffm-"

        ('ff' is file selector: 00 SGPRs, 01 SPRs, 10 VGPRs, 11 HLPRs)
        ('m' is mask: 0 unmasked, 1 masked)

    test branches & mask setting:

        MOD(04): "ttff"

        ('tt' is data type length: 8, 16, 32, 64)
        ('ff' is condition: 00 EQZ, 01 NEZ, 10 LTZ, 11 LEZ)

    direct function calls & jumps:

    	MOD(04): "iiii"

    	('i' is extra immediate)

    bit-field manipulations:

        MOD(04): "ttmc"

        ('m' is mask: 0 unmasked, 1 masked)
        ('tt' is data type length: 8, 16, 32, 64)
        ('c' imm extend mode: ...)
}
______________________________________________________________________________________________________________________________________________________________________

[G] format {
	
	[G]   |OPCODE(07)|MOD(03)|RD/RS1(03)|RS2(03)|    length: 2B

    type: R,R

	compressed computational instructions:

        MOD(02): "tto"

        ('tt' is data type length: 8, 16, 32, 64)
        ('o' is extra opcode bit)
}
______________________________________________________________________________________________________________________________________________________________________

[H] format {

    type: R
	
	[H]   |OPCODE(11)|RS(05)|    length: 2B
}
______________________________________________________________________________________________________________________________________________________________________

[I] format {

    type: R,I
	
	[I]   |OPCODE(07)|RA(03)|IMM(06)|    length: 2B
}
______________________________________________________________________________________________________________________________________________________________________

[J] format {

    type: I
	
	[J]   |OPCODE(07)|IMM(09)|    length: 2B
}
______________________________________________________________________________________________________________________________________________________________________

[K] format {

    type: O
	
	|OPCODE(16)|    length: 2B
}
______________________________________________________________________________________________________________________________________________________________________
